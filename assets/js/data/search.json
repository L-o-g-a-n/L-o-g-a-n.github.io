[ { "title": "C++ 입출력 속도 개선", "url": "/posts/cpp-io-speed/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++", "date": "2022-07-20 00:00:00 +0900", "snippet": "저번 포스팅에서 언급했던 것처럼 요즘은 프로그래머스에서 넘어와 백준이라는 사이트에서 알고리즘 및 코딩 테스트 공부를 하고 있습니다. 이에 따라 입출력 처리를 직접 해줘야하는 경우가 생기는데, C++이 기본적으로 C의 입출력보다 많이 느려서 이를 개선하는 방법에 대한 포스팅을 해보려고 합니다.C++ 입출력 속도 C와 비교했을 때 C++의 입출력 속도는 얼마나 느린 것인지 알아봤습니다. 실제로 실험 결과를 봤을 때 출력의 경우 큰 차이가 없었지만 입력의 경우 scanf를 쓰는 경우 평균 0.9206초가 걸리고 cin을 쓰는 경우는 평균 2.1742초가 걸리며 2배 이상의 차이가 났습니다. 지금부터는 이렇게 늦은 속도를 어떻게 개선할 수 있는지 알아봅시다.C++ 입출력 속도 개선 결론부터 말하자면 C++ 내 메인 함수에서 아래의 코드를 작성해주면 속도 개선을 할 수 있습니다. ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); 위 코드를 통해 C와 C++의 stream 동기화를 끊을 수 있습니다. 동기화를 끊는다는 것은 C++이 독립적인 buffer를 가지게 된다는 것을 의미합니다. 이에따라 buffer의 크기가 줄어들어 속도 개선이 이뤄질 수 있습니다. 이렇게 하면 출력한 뒤 바로 화면에 보이지 않고 프로그램 실행이 끝난 뒤 한번에 보여지게 됩니다. 하지만 이는 알고리즘 문제를 풀 때 문제가 되지 않습니다. 사실 그것보다 중요한 문제는 이처럼 했을 때 C의 표준 입출력을 함께 사용해서는 안된다는 점입니다. 예를 들어 scanf, printf, getchar 등의 함수를 쓸 수 없습니다. C와 C++의 표준 입출력을 함께 사용하게 되면 동기화를 끊어 놨기 때문에 프로그래머가 기대한대로 출력 순서가 보장되지 않기 때문입니다. 참고로 getline은 C++의 표준 입출력을 사용하기 때문에 정상적인 사용이 가능합니다. 그 외에도 멀티 스레드가 아닌 싱글 스레드 환경에서만 사용 가능합니다. 하지만 알고리즘 문제를 풀면서 멀티 스레드 환경을 사용할 일은 없으므로 이 부분 역시 걱정 안하셔도 됩니다. 이렇게 버퍼를 분리시켜준 뒤에 속도 측정을 다시 해보니 cin을 사용했을 때 평균 0.5938초가 걸린다고 합니다. 이는 scanf와 비교했을 때 거의 2배 가까이 빠른 속도를 보여주는 것입니다. 출력을 하기 위한 cout 같은 경우에는 평균 0.8272초로 거의 차이가 안났습니다.endl 대신 ‘\\n’ 사용 입출력 속도 개선을 위해 추가적으로 endl 대신 ‘\\n’을 사용하는 습관을 들여야 합니다. endl은 개행 문자를 출력할 뿐만 아니라 출력 버퍼를 비우는 역할까지 합니다. 그런데 이 버퍼를 비우는 작업이 굉장히 오래 걸립니다. 우리가 알고리즘 문제를 풀면서 반복되는 개행 문자의 입출력이 있을텐데 endl을 사용한다면 그때마다 이렇게 시간적인 손해를 보게 되는 것입니다. 따라서 ‘\\n’을 사용하여 이렇게 낭비되는 시간을 줄입시다.References https://www.acmicpc.net/board/view/22716https://ip99202.github.io/posts/%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%86%8D%EB%8F%84-%EC%A4%84%EC%9D%B4%EA%B8%B0/" }, { "title": "cout 소수점 자릿수 조절", "url": "/posts/cout-digit/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++", "date": "2022-07-20 00:00:00 +0900", "snippet": "최근 개인적으로 알고리즘 및 코딩 테스트 준비 사이트를 프로그래머스에서 백준으로 이동하였습니다. 백준과 프로그래머스의 가장 큰 차이점으로 백준은 입력에 대한 처리를 프로그래머가 직접 해줘야 합니다. 그래서 오늘은 입출력과 관련된 부분 중에서 cout을 통해 출력할 때 소수점 및 숫자의 출력 자릿수를 설정하는 방법에 대하여 알아보도록 하겠습니다.소수점 출력 자릿수 조절 우리는 기본적으로 C++에서 실수를 다룰 때 float와 double과 같은 자료형에 담게 됩니다. 이러한 데이터 타입에 따라 표현할 수 있는 실수의 자릿수는 다 다르겠지만 우리가 별도의 설정 없이 cout을 통하여 float 및 double형의 숫자를 출력하면 정수부+실수부 포함해서 총 6자리까지만 출력이 됩니다. 그 이유는 cout을 통해 출력하는 수의 자릿수 default가 최대 6자리로 되어 있기 때문입니다.따라서 출력되는 소수점 자릿수를 조절하려면, 별도의 세팅이 필요한데 우리는 아래의 두 함수를 통해 이를 해결할 수 있습니다.cout &lt;&lt; fixed; //소수점을 고정시켜 표현cout.precision(6); //6자리까지 표현위 두 함수를 순차적으로 실행하게 되면, “소수점을 고정시켜 소수점이 6자리까지 출력되도록 표현하겠다.”라는 의미를 갖게 됩니다. 만약 실수형 변수에 담긴 소수점이 해당 설정값인 6자리보다 길다면 7번째 자리에서 반올림하여 출력된다는 것도 알아두시면 좋을 것 같습니다. 또한 위에서 고정시킨 소수점을 해제하고 싶다면 아래와 같은 코드를 사용하면 됩니다.cout.unsetf(ios::fixed);반대로, 위에서 소수점을 고정시키기 위해 사용했던 “cout « fixed;”는 아래처럼 setf() 함수로 대체 사용 가능합니다.cout.setf(ios::fixed);References https://pmoncode.tistory.com/20" }, { "title": "카카오_ 완전탐색 - Level2 - 거리두기 확인하기", "url": "/posts/social-distancing/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, exhaustive search, 카카오, 거리두기 확인하기, 완전탐색, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2022-07-18 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 카카오 - 거리두기 확인하기 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int vector_to_array(vector&lt;string&gt; v1, char arr[][5]) { for(int i=0; i&lt;5; i++) { for(int j=0; j&lt;5; j++) { arr[i][j] = v1[i][j]; } } return 0;}int calc(char arr[][5]) { for(int i=0; i&lt;5; i++) { for(int j=0; j&lt;5; j++) { if(arr[i][j] == 'P') { if(i+1 &lt;= 4) { if(arr[i+1][j] == 'P') return 0; } if(i-1 &gt;= 0) { if(arr[i-1][j] == 'P') return 0; } if(j+1 &lt;= 4) { if(arr[i][j+1] == 'P') return 0; } if(j-1 &gt;= 0) { if(arr[i][j-1] == 'P') return 0; } if(i+1&lt;=4 &amp;&amp; j+1&lt;=4) { if(arr[i+1][j+1] == 'P') { if(arr[i+1][j] != 'X') return 0; if(arr[i][j+1] != 'X') return 0; } } if(i-1&gt;=0 &amp;&amp; j+1&lt;=4) { if(arr[i-1][j+1] == 'P') { if(arr[i-1][j] != 'X') return 0; if(arr[i][j+1] != 'X') return 0; } } if(i-1&gt;=0 &amp;&amp; j-1&gt;=0) { if(arr[i-1][j-1] == 'P') { if(arr[i][j-1] != 'X') return 0; if(arr[i-1][j] != 'X') return 0; } } if(i+1&lt;=4 &amp;&amp; j-1&gt;=0) { if(arr[i+1][j-1] == 'P') { if(arr[i][j-1] != 'X') return 0; if(arr[i+1][j] != 'X') return 0; } } if(i+2&lt;=4) { if(arr[i+2][j] == 'P') { if(arr[i+1][j] != 'X') return 0; } } if(j+2&lt;=4) { if(arr[i][j+2] == 'P') { if(arr[i][j+1] != 'X') return 0; } } if(i-2&gt;=0) { if(arr[i-2][j] == 'P') { if(arr[i-1][j] != 'X') return 0; } } if(j-2&gt;=0) { if(arr[i][j-2] == 'P') { if(arr[i][j-1] != 'X') return 0; } } } } } return 1;}vector&lt;int&gt; solution(vector&lt;vector&lt;string&gt;&gt; places) { vector&lt;int&gt; answer; for(int i=0; i&lt;places.size(); i++) { char arr[5][5]; vector_to_array(places[i], arr); answer.push_back(calc(arr)); } return answer;}이 문제는 완전 탐색 문제로, 문제를 풀고 난 뒤에 다른 사람들의 풀이들을 보니 DFS나 BFS를 활용해서 풀이하신 분들이 많았습니다. 저와 같은 경우에는 사람 “P”의 입장에서 가능한 모든 경우의 수를 조건문을 활용해서 풀이하였는데 이렇게 풀고보니 정답은 맞았지만 굉장히 지저분해서 아쉬움이 많이 남습니다. 문제의 조건을 코드로 옮겨 적은 느낌이라 코드를 보시면 쉽게 이해가 가능해서 별도의 풀이는 적지 않겠습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool is_valid_place(const vector&lt;string&gt;&amp; place){ constexpr size_t N = 5; vector&lt;vector&lt;int&gt;&gt; is_in_use( N, vector&lt;int&gt;(N, false) ); int di[] = {1,-1,0,0}; int dj[] = {0,0,1,-1}; for(size_t i=0; i!=N; ++i) for(size_t j=0; j!=N; ++j) if(place[i][j] == 'P'){ for(size_t k=0; k!=4; ++k){ size_t moved_i = i + di[k]; size_t moved_j = j + dj[k]; if(moved_i &gt;= N || moved_j &gt;= N) continue; switch(place[moved_i][moved_j]){ case 'P': return false; case 'O': if(is_in_use[moved_i][moved_j]) return false; is_in_use[moved_i][moved_j] = true; break; case 'X': break; } } } return true;}vector&lt;int&gt; solution(vector&lt;vector&lt;string&gt;&gt; places) { vector&lt;int&gt; answer(5); for(size_t i=0; i!=5; ++i) answer[i] = is_valid_place(places[i]); return answer;}위 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 위 풀이를 간단히 이해하기 좋게 설명해보자면, is_in_use라는 2차원 벡터에 모두 false값을 채워 만들고 ‘P’ 원소를 가지는 좌표에서 사방으로 한 칸씩 움직이며 ‘P’를 만나는지 ‘O’를 만나는 지에 따라 문제의 조건을 해결합니다. ‘P’를 만나는 경우에는 당연히 거리두기에 실패한 것이고 ‘O’를 만나는 경우에는 누군가 ‘O’에 1칸 거리에 있다는 것을 표현하기 위해 is_in_use를 true로 바꿔줍니다. 그 후 다른 ‘P’가 위처럼 사방으로 한 칸씩 움직이다가 누군가 왔다간 흔적(is_in_use가 true)를 발견한다면 그것 또한 거리두기에 실패한 것으로 처리할 수 있게 됩니다. 한줄로 요약하면, ‘P’ 원소를 기준으로 사방으로 한 칸씩 움직여서(한 칸 움직인 뒤 만난 원소가 ‘O’일때만 움직일 수 있음) 인접한 ‘P’와 만날 수 있는 지를 검사하여 거리두기를 검사한 로직입니다.최적화한 나의 풀이최적화한 풀이가 다른 사람이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다." }, { "title": "카카오_ 문자열 - Level1 - 신고 결과 받기", "url": "/posts/receive-report-results/", "categories": "Computer science, Algorithm", "tags": "level1, programmers, string, 카카오, 신고 결과 받기, 문자열, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2022-07-18 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 카카오 - 신고 결과 받기 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;string&gt; id_list, vector&lt;string&gt; report, int k) { vector&lt;int&gt; answer(id_list.size()); //일단 report에서 중복 제거 vector&lt;int&gt; call_count(id_list.size()); set&lt;string&gt; s1(report.begin(), report.end()); // unodered_map&lt;string,string&gt; find_caller_map; vector&lt;pair&lt;string,string&gt;&gt; caller_callee; unordered_map&lt;string,int&gt; name_map; for(int i=0; i&lt;id_list.size(); i++) { //빠른 연산을 위해 언오더드 맵에 이름, 인덱스 저장 name_map[id_list[i]] = i; } for(auto it=s1.begin(); it!=s1.end(); ++it) { stringstream ss(*it); string caller,callee; ss &gt;&gt; caller; ss &gt;&gt; callee; // find_caller_map[callee] = caller; caller_callee.push_back(make_pair(caller, callee)); call_count[name_map[callee]]++; } for(int i=0; i&lt;call_count.size(); i++) { if(call_count[i] &gt;= k) { for(auto name_index: name_map) { if(name_index.second == i) { for(auto cc: caller_callee) { if(cc.second == name_index.first) { answer[name_map[cc.first]]++; } } } } } } return answer;}이 문제는 문자열 관련 문제로 Level1임에도 불구하고 시간도 꽤 오래 걸리고 소스 코드도 풀면 풀수록 점점 길어져서 많이 당황스러웠던 문제입니다. 그리고 시간 복잡도를 고려안할 수가 없어서 최대한 빠른 자료 구조를 사용하고자 다양하게 시도해봤더니 헤더 파일 개수만 엄청 늘어났습니다. 그러던 와중 문제를 다 풀고나서 다른 사람 풀이와 비교해보니 로직 자체가 굉장히 비슷해서 놀랐습니다. 이 문제는 report에서 먼저 중복을 제거해주고 문자열 토크나이징 해준 뒤에 신고한 사람과 신고 받은 사람을 잘 묶어 문제 조건에 맞게 사용해주면 쉽게 해결할 수 있습니다.다른 사람의 풀이1#include &lt;bits/stdc++.h&gt;#define fastio cin.tie(0)-&gt;sync_with_stdio(0)using namespace std;vector&lt;int&gt; solution(vector&lt;string&gt; id_list, vector&lt;string&gt; report, int k) { // 1. const int n = id_list.size(); map&lt;string, int&gt; Conv; for (int i = 0; i &lt; n; i++) Conv[id_list[i]] = i; // 2. vector&lt;pair&lt;int, int&gt;&gt; v; sort(report.begin(), report.end()); report.erase(unique(report.begin(), report.end()), report.end()); for (const auto&amp; s : report) { stringstream in(s); string a, b; in &gt;&gt; a &gt;&gt; b; v.push_back({ Conv[a], Conv[b] }); } // 3. vector&lt;int&gt; cnt(n), ret(n); for (const auto&amp; [a, b] : v) cnt[b]++; for (const auto&amp; [a, b] : v) if (cnt[b] &gt;= k) ret[a]++; return ret;}위 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 제 풀이와 로직 자체는 굉장히 비슷합니다. 저는 set 자료 구조를 활용해서 중복을 제거해준 반면에 이 풀이에서는 unique와 erase를 활용하여 중복을 제거해 줬습니다. 제가 생각했을 때 이 풀이가 제 풀이보다 간결하고 효율적일 수 있었던 이유는 처음부터 사용자들의 이름을 index와 매핑시킨 뒤 쭉 index로만 접근했다는 점입니다. 저는 이름과 index를 일관성있게 매핑시키지 않아서 이 두 관계를 판단하고 변환하는데 많은 비용을 들였습니다. 이 부분 외에는 로직 자체가 굉장히 똑같습니다.최적화한 나의 풀이최적화한 풀이가 다른 사람이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다." }, { "title": "카카오_ 문자열 - Level1 - 숫자 문자열과 영단어", "url": "/posts/nums-and-words/", "categories": "Computer science, Algorithm", "tags": "level1, programmers, string, 카카오, 숫자 문자열과 영단어, 문자열, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2022-07-17 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 카카오 - 숫자 문자열과 영단어 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(string s) { int answer = 0; vector&lt;string&gt; num = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}; for(int i=0; i&lt;num.size(); i++) { while(s.find(num[i]) != string::npos) { s.replace(s.find(num[i]), num[i].size(), to_string(i)); } } return answer = stoi(s);}이 문제는 Level1이기 때문에 어렵지 않게 풀 수 있었습니다. 어떻게하면 최적의 알고리즘을 구할 수 있을지 먼저 고민하였고 그 결과 위처럼 풀이하였습니다. 위 알고리즘에서 핵심 메소드는 find와 replace입니다. str.find(str1)를 하면 str에서 str1 부분을 찾아 해당 부분이 시작하는 인덱스 번호를 리턴해줍니다. 여기서 주의할 것은 이터레이터가 아닌 인덱스 번호입니다. 또한 찾지 못할 경우에는 string::npos를 리턴함을 잊어서는 안됩니다.그다음으로 위 로직에서 중요한 메소드는 str.replace(시작 인덱스, 길이, 대체할 문자열)입니다. str의 시작 인덱스로부터 길이만큼의 부분 문자열을 대체할 문자열로 대체해주는 함수입니다. 이 두가지 함수만 잘 활용한다면 손쉽게 위 문제를 해결할 수 있습니다.다른 사람의 풀이1#include &lt;bits/stdc++.h&gt;using namespace std;int solution(string s) { s = regex_replace(s, regex(\"zero\"), \"0\"); s = regex_replace(s, regex(\"one\"), \"1\"); s = regex_replace(s, regex(\"two\"), \"2\"); s = regex_replace(s, regex(\"three\"), \"3\"); s = regex_replace(s, regex(\"four\"), \"4\"); s = regex_replace(s, regex(\"five\"), \"5\"); s = regex_replace(s, regex(\"six\"), \"6\"); s = regex_replace(s, regex(\"seven\"), \"7\"); s = regex_replace(s, regex(\"eight\"), \"8\"); s = regex_replace(s, regex(\"nine\"), \"9\"); return stoi(s);}처음보고 C++ 코드가 아닌 줄 알았습니다. 생전 처음 보는 헤더 파일과 메소드였습니다. 하지만 메소드 명을 보고 정규표현식과 관련된 함수라는 것은 눈치챌 수 있었습니다. 그래서 지금부터는 regex_replace() 메소드에 대하여 알아보려고 합니다.regex_replace()란? regex_replace()는 대상 문자열에서 문자열을 검색해 치환하기 위해서 사용할 수 있습니다. 이 함수는 &lt;regex&gt;에 들어있으며 사용 방법은 아래와 같습니다. regex_replace.(대상 문자열, regex(정규식), 치환 문자열) 이렇게 함수를 사용하면 대상 문자열에서 정규식에 지정한 문자열과 일치하는 문자열을 모두 치환 문자열로 대체한 뒤 바뀐 대상 문자열을 리턴해 줍니다.최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.References https://ponyozzang.tistory.com/678" }, { "title": "알아두면 쓸모있는 C++ STL 정리 7", "url": "/posts/cpp-stl7/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-17 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.stringstream이란? stringstream은 주어진 문자열에서 필요한 정보를 빼낼 때 유용하게 사용됩니다. 특히나 본인이 stringstream에 전달해주는 자료형과 일치하는 부분만 공백,’\\n’을 무시하고 추출해 줍니다. stringstream은 &lt;sstream&gt; 헤더 파일 내에 구현되어 있습니다. stringstream을 사용하려면 우선 아래와 같이 객체를 선언해줘야 합니다. stringstream ss(input); stringstream 클래스 내 생성자를 활용해서 input이라는 string 값을 가지는 객체를 생성한 것인데 위처럼 선언 시에 해줘도 되고 객체 선언 먼저 한뒤에 아래처럼 stringstream에 들어가있는 string 값을 바꿔주거나 새로 넣어줄 수도 있습니다. ss.str(input); 근데 여기서 주의할 점이 있습니다. 만약 stringstream 객체 내 들어있는 string 값을 위처럼 계속 변경해가며 재활용한다면 이전 string 값을 사용하면서 발생한 flag들이 그대로 저장되어 있어 올바른 작동을 하지 못할 수도 있으므로 재활용을 하고 싶다면 string 값을 바꿔줄 때마다 먼저 아래와 같이 반드시 clear를 한번씩 해주고 사용합시다. ss.clear(); 그렇다면 지금부터는 이제 어떻게 stringstream 객체를 활용해서 공백과 ‘\\n’을 기준으로 문자열을 토크나이징 할 수 있을지 알아보겠습니다. 방법은 굉장히 간단합니다. 토크나이징한 부분 문자열을 담을 변수를 가지고 아래와 같이 사용해주면 끝입니다. ss &gt;&gt; name; 위처럼 사용하면 1개의 토큰이 name으로 추출됩니다. 이걸 문자열 끝까지 반복하여 모두 토크나이징 하고 싶다면 아래와 같이 하면 됩니다. while(ss &gt;&gt; name) { cout &lt;&lt; name &lt;&lt; endl;} 여기서 반드시 기억해야될 점이 있습니다. 토크나이징을 담을 변수의 데이터 타입에 맞는 데이터까지만 추출됩니다. 데이터 타입이 맞지 않는 토큰을 만나게 되면 그 자리에서 바로 while문이 중단됩니다. 위에서 name이 string이라면 string 타입에 맞는, 즉 ss라는 stringstream 객체가 가지고 있는 문자열 내에서도 문자와 관련된 값들이 나타나는 곳까지만 추출되는 것입니다. 만약에 stringstream이 가지고 있는 string이 “as df 6.3 qw”이고 name이 string 데이터 타입을 가진다면 as, df, 6.3, qw 모두 추출하고 위 반복문이 끝나게 되겠지만 ss가 가지는 string이 “23 512 a 175”이고 int형 데이터 타입을 가지는 num이라는 변수에 추출을 한다면 23과 512를 추출하고 반복문이 끝나게 됩니다. 만약 string이 “23 512 1.75 a 2”이고 int형 데이터 타입을 가지는 num에 추출한다면 이 경우에는 특별하게 float형인 1.75를 형변환해서 1로 추출하고 위 반복문이 끝나게 된다는 것도 기억해두시길 바랍니다.strtok(), strtok_s()란? strtok(), strtok_s()는 문자열을 토크나이징 해주는 함수입니다. C 스타일의 문자열, 즉 char* 배열만 사용 가능하며 C++에서 이를 사용하려면 &lt;cstring&gt; 헤더 파일을 인클루드 해줘야 합니다. 함수 원형은 아래와 같습니다. char *strtok(char *_String, const char *_Delimit);char *strtok_s(char *_String, const char *_Delimit, char **_Context); String: 자르고자 하는 문자열Delimit: 자를 기준을 정하는 구분자Context: 자르고 남은 문자열 (이중 포인터임에 주의, 즉 char*의 주소를 넘겨줘야 함)strtok()와 strtok_s()를 사용한 예제 코드는 아래와 같습니다.int main() { char str[] = \"MY NAME IS LOGAN\"; //대상 문자열 char *temp = strtok(str,\" \"); //공백을 기준으로 문자열 자르기 while (temp != NULL) { //널이 아닐때까지 반복 printf(\"%s\\n\",temp); // 출력 temp = strtok(NULL, \" \");\t//널문자를 기준으로 다시 자르기 }\t return 0;}int main() { char str[] = \"MY NAME IS LOGAN\"; //대상 문자열 char* str2 = NULL; char* temp = strtok_s(str, \" \", &amp;str2); //공백을 기준으로 문자열 자르기 while (temp != NULL) { //널이 아닐때까지 반복 printf(\"잘린 문자열 : %s\\n\", temp); // 출력 printf(\"자르고 남은 문자열 : %s\\n\", str2); temp = strtok_s(NULL, \" \", &amp;str2);\t//널문자를 기준으로 다시 자르기 } return 0;}위 두 함수의 동작 원리는 파라미터로 넘겨받은 구분자를 ‘\\0’으로 바꿔 토크나이징 하는 방식입니다. C에서는 문자열의 구분을 ‘\\0’으로 하기 때문에 이것이 가능한 것입니다. 함수 내부적으로 구분자를 탐색하여 그 값을 ‘\\0’으로 바꾸기 때문에 파라미터로 넘겨주는 문자 배열이 const 형이어서는 안되고, 문자열 상수여서도 안됩니다. 즉, 실제 메모리를 잡고 존재하는 const가 아닌 char 배열이어야 합니다. 그래서 보통 C++ 문자열인 string 객체에 strtok() 함수를 사용하려고 하면 아래와 같은 전처리를 거칩니다.char str_buff[1000]; //strtok 매개변수로는 실체가 있는 문자 배열만이 가능하므로 문자 배열 선언 strcpy(str_buff, s1.c_str()); //우선 string 객체 s1을 c_str()를 통해 string을 char* 형으로 바꿔줍니다. 하지만 c_str()은 const형을 리턴하므로 strcpy를 활용하여 const가 아닌 실제 배열에 담아 줍니다또한 위 함수를 사용하여 한번 토크나이징 한 뒤에는 계속 NULL 포인터를 파라미터로 넘겨주는 이유는 strtok 내부 동작 원리 자체가 null 값을 넘겨주면 이전에 찾은 구분자 뒤에서부터 찾도록 구현이 되어있기 때문입니다. 만약에 토크나이징 하다가 더이상 자를 게 없는 문자열 끝에 도달하게 되면 strtok()는 null 값을 리턴하게 된다는 것도 알아두시면 좋을 것 같습니다.이차원 배열 전달 이차원 배열을 함수의 파라미터로 전달할 때 이중 포인터를 써야하는지, 어떻게 넘겨야할 지 종종 헷갈릴 때가 있습니다. 그래서 아래와 같이 정리합니다.void functionArray1(int arr[][5], int col, int row) // 2차원 배열 넘겨줄 때 열의 개수를 반드시 써줘야 한다{ ...}void functionArray2(int (*arr)[5], int col, int row) // 2차원 배열 넘겨줄 때 열의 크기를 반드시 써줘야 한다{ ...}2차원 배열을 넘겨줄 땐 반드시 열의 개수를 써줘야 합니다. 열의 개수를 기준 삼아 행의 개수도 자동으로 구하기 때문입니다. 이렇게 선언한 함수를 호출할 때는 그냥 아래와 같이 배열 이름만 넘겨주면 됩니다.functionArray(numArr, col, row);References https://coding-factory.tistory.com/592https://an-thropology.tistory.com/22" }, { "title": "알아두면 쓸모있는 C++ STL 정리 6", "url": "/posts/cpp-stl6/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-17 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.next_permutation()이란? next_permutation()은 C++ algorithm 헤더 파일 내 순열 기능을 제공하는 메소드입니다. 기본적으로 next_permutation()은 파라미터로 iterator를 넘겨 받기 때문에 vector 뿐만 아니라 string 타입의 순열도 구할 수 있습니다. 이 메소드 내부 로직은 더 큰 순열로 재배열할 수 있을 때까지 계속 반복하여 구해내는 방식을 취하고 있어서 앞에 이미 큰 원소들이 배치되어 있으면 모든 순열의 경우의 수를 구할 수 없습니다. 따라서 본 함수를 사용하기 전에 오름차순으로 정렬 시켜놓은 뒤에 사용해야 모든 순열의 경우의 수를 구할 수 있습니다. 아래는 1,2,3,4의 숫자를 가지고 만들 수 있는 순열을 구하는 코드 예시입니다.string s = \"123\";do {\tcout &lt;&lt; s &lt;&lt; \" \"; //do while문을 반복할 때마다 s가 새로운 순열로 재배열됌} while (next_permutation(s.begin(), s.end()));위 코드를 작동시키면 아래와 같은 결과가 출력될 것입니다.123132213231312321위 결과를 보면 알 수 있듯이 처음에 인자로 넘겨준 string의 size에 따라 해당 size의 순열만이 결과로 출력되게 됩니다. 위 예시 같은 경우에는 string s가 size 3을 가지므로 3자리 수의 순열이 출력된 것입니다. 만약에 1자리 수부터 3자리 수까지의 모든 순열을 구하고 싶다면 아래와 같이 substr과 set(중복되는 부분 순열을 제거)을 활용하면 됩니다.string s = \"123\";set&lt;int&gt; set1;string sub;do { for(int i=1; i&lt;=s.size(); i++) { sub = s.substr(0,i); set1.insert(stoi(sub)); //여기 substr()에 string의 이터레이터를 넣어주면 에러가 발생한다. 반드시 인덱스 번호를 넘겨줄 것 }} while (next_permutation(s.begin(), s.end()));위에서 주의할 것은 substr()에는 반드시 index number만 들어갈 수 있다는 점입니다. string의 iterator가 들어갈 수 없음을 알아둡시다.next_permutation()을 활용한 조합 앞서 next_permutation()을 활용해서 순열을 구현할 수 있다고 배웠습니다. 지금부터는 이러한 next_permutation()을 활용해서 조합을 구현해볼 것입니다. 로직은 아래와 같습니다. 1. 구하고자 하는 조합 nCr에서 n의 개수에 맞게 시퀀스 컨테이너(벡터 혹은 배열 등)을 만듭니다.2. 앞서 만든 컨테이너에 r의 개수만큼 1로 채워주고 n-r개 만큼 0을 채워줍니다.3. next_permutation()을 사용하기 위해 위 컨테이너를 오름차순 정렬 해줍니다.4. do while문을 사용하여 next_permutation()을 사용합니다.5. do while문 내에서 순열을 조회하면서 원소로 1을 가지는 곳의 index들이 조합의 경우의 수들입니다. static_cast&lt;&gt;란? static_cast&lt;&gt;란 형 변환을 도와주는 정적 캐스트 연산자입니다. 정적이라는 이름은 “컴파일 시간”에 형 변환이 올바르게 가능한지를 검사한다는 말입니다. 런타임 시간에 에러가 발생할 것 같으면 컴파일 시간에 미리 검사하여 에러를 발생시킵니다. 이와 다르게 dynamic_cast&lt;&gt;와 같은 동적 캐스트 연산자도 있는데 이는 런타임 시간에 형 변환에 대한 안정성 검사를 실시합니다. 가장 큰 차이점으로는 dynamic_cast&lt;&gt;는 기본 자료형 간의 형 변환은 지원하지 않습니다. 따라서 기본 자료형 간의 형 변환을 할 시에는 반드시 static_cast&lt;&gt;를 사용해줘야 합니다. 사용 예시는 아래와 같습니다. int a;float b;a = static_cast&lt;int&gt;(b); " }, { "title": "알아두면 쓸모있는 C++ STL 정리 5", "url": "/posts/cpp-stl5/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-17 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.lower_bound(), upper_bound()이란? lower_bound()는 C++ algorithm 헤더 파일 내에 있는 메소드로 유사한 기능의 함수로 upper_bound()가 있습니다. 알고리즘 혹은 C++ STL 공부를 꾸준히 하신 분이라면 이미 위 함수명에 익숙하실 것입니다. set, map 컨테이너와 같이 정렬 되어있는 컨테이너에서는 이미 멤버 함수로 별도 제공하고 있기 때문입니다. algorithm에 있는 위 두 함수는 내부적으로 이진 탐색을 활용하기 때문에 컨테이너의 원소가 정렬되어 있는 상태에서만 사용 가능합니다. vector와 같이 원소 정렬이 default가 아닌 컨테이너들에게도 위 기능을 제공하기 위해 algorithm 헤더 파일 내에 별도로 존재한다고 이해하시면 좋을 것 같습니다.위 두 함수의 원형은 아래와 같습니다.template &lt;class ForwardIt, class T&gt;ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value);ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value);범위를 나타내는 이터레이터와 value를 넘겨주면 lower_bound()는 범위 내에서 기준값과 같거나 그것보다 큰 원소중에 가장 작은 원소의 위치를 이터레이터로 리턴합니다. upper_bound()는 기준값보다 큰 원소중에 가장 작은 원소의 위치를 이터레이터로 리턴합니다. 두 함수 모두 적당한 원소를 찾지 못하였으면 last 이터레이터를 리턴합니다.max_element(), min_element()란? C++ algorithm 라이브러리에 존재하는 메소드로 파라미터로 넘겨받은 이터레이터 범위 내 원소 중 최대, 최소의 이터레이터를 반환해줍니다. C++에서는 array 역시 클래스형 객체로 취급되어 아래와 같이 array도 이 함수를 사용할 수 있습니다. 그 이외 vector나 string과 같이 이터레이터를 가지고 있는 자료구조 모두 사용 가능합니다. int arr[] = {1,2,3,4,5};vector&lt;int&gt; v1 = {1,2,3,4,5};*max_element(arr, arr+5); //여기서 5는 array size인데 직접 구하려면 sizeof(arr)/sizeof(arr[0])*max_element(v1.begin(), v1.end()); 문자열 sort() 심화 프로그래머스 고득점 “가장 큰 수” 문제를 풀다가 가장 어려웠던 로직입니다. 부분 숫자 문자열들을 이어 붙여서 가장 큰 수를 만드는 문제였는데, “3”, “30”이 있을 때 사전 순으로 따지면 “30”이 “3”보다 커서 “303”이 되어야 할 것 같지만 실제 숫자는 “330”이 더 커서 문제였습니다. 그럴 때는 어차피 부분 문자열들을 이어 붙인 뒤 가장 큰 수를 비교하므로 부분 문자열을 이어 붙인 상태로 사전 순을 비교하면 해결됩니다. 이게 말만 들어서는 잘 이해가 안될텐데 코드를 보면 이해가 되실 겁니다. vector&lt;string&gt; nums;bool compare(string lhs, string rhs) { return lhs+rhs &gt; rhs+lhs;}sort(nums.begin(), nums.end(), compare); set이란? set은 multiset, map, multimap 등을 포함하는 연관 컨테이너(associate container) 중 하나입니다. 연관 컨테이너란 key와 value처럼 관련있는 데이터를 쌍으로 저장하는 컨테이너를 말합니다. 그중에서도 set은 가장 단순한 연관 컨테이너로 value를 key값 그 자체로 사용하여 즉 쌍이 아닌 value 하나만을 원소로 사용합니다. set에서는 중복을 허용하지 않고 set.insert()를 통해 원소를 삽입하는데 원소가 들어올 때 기본적으로 오름차순으로 정렬되어 삽입됩니다.지금부터는 다양한 set의 멤버 함수에 대하여 알아보겠습니다. s.count(k)원소 k의 개수를 리턴합니다. set은 중복을 허용하지 않기 때문에 0 또는 1의 값만을 가질 것입니다. 중복을 허용하는 multiset일 경우 더 큰 값을 가질 수 있습니다. s.empty()set s가 비어있는지 확인합니다. s.insert(k)set s에 원소 k를 자동으로 정렬된 위치에(오름차순) 삽입합니다. 리턴값으로 pair&lt;iterator, bool&gt;으로 나오게 되며 iterator는 삽입된 위치를 나타내며 bool은 삽입 성공 여부를 나타냅니다. s.erase(k)원소 k 값을 set에서 제거합니다. s.erase(iterator)iterator가 가리키는 위치에 있는 원소를 제거합니다. s.erase(start iterator, end iterator)[start, end) 범위 내의 모든 원소를 제거합니다. s.find(k)원소 k의 이터레이터를 반환합니다. 만약 찾을 수 없을 경우 s.end()와 같은 반복자를 반환합니다. s.upper_bound(k)원소 k보다 큰 원소 중 가장 작은 원소의 이터레이터를 반환합니다. s.lower_bound(k)원소 k보다 크거나 같은 원소 중 가장 작은 원소의 이터레이터를 반환합니다. s.size()원소의 개수를 반환합니다.References https://blockdmask.tistory.com/79" }, { "title": "알아두면 쓸모있는 C++ STL 정리 4", "url": "/posts/cpp-stl4/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-16 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.heap이란? heap이란 완전 이진 트리의 일종으로 우선순위 큐 구현을 위해 만들어진 자료구조입니다. 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아가기 위해 만들어졌습니다. 힙은 일종의 반정렬 상태(느슨한 정렬 상태)를 유지합니다. 힙에서 부모 노드와 자식 노드 간에는 대소 관계가 명확히 유지되지만 형제 노드 간에는 아무런 의미도 없기 때문입니다. 부모 노드의 키 값이 자식 노드의 키 값보다 큰 경우는 최대 힙(max heap), 부모 노드의 키 값이 자식 노드의 키 값보다 작은 경우에는 최소 힙(min heap)이라고 부릅니다.priority queue란? 우선순위 큐는 큐 중에서도 우선순위가 있는 큐를 말합니다. 큐라고 하면 FIFO(First In First Out)을 구현한 자료 구조로 먼저 들어온 원소가 먼저 나가게 되는 LIFO(Last In First Out)을 구현한 Stack과 반대되는 자료 구조입니다. 즉, 우선순위 큐에서는 우선순위가 높은 데이터가 먼저 나가게 되는 구조입니다. 우선 순위 큐는 기본적으로 배열, 연결리스트, 힙 등으로 구현이 가능한데 그 중에서도 힙으로 구현하는 것이 원소의 삽입, 삭제에 있어서 시간 복잡도가 O(log n)으로 가장 효율적이기 때문에 힙으로 구현한 우선순위 큐가 가장 많이 쓰입니다. C++ STL에서도 priority queue를 heap으로 구현하고 있습니다.우선순위 큐는 &lt;queue&gt; 헤더 파일을 인클루드하여 사용할 수 있습니다. 다음은 우선순위 큐 선언 방법입니다. 기본적인 원형은 priority_queue&lt;자료형,구현체,비교 연산자&gt; 입니다.priority_queue&lt;int&gt; pq1;priority_queue&lt;pair&lt;char,int&gt;&gt; pq2;여기서 구현체란, 우선순위 큐를 만들 때 사용할 자료구조를 뜻하며 일반적으로는 vector를 사용합니다. 비교 연산자는 우선순위를 나타내는 정렬 기준으로 커스텀해서 사용하는 것도 가능하지만 일반적으로는 less&lt;자료형&gt;, greater&lt;자료형&gt;을 사용하며 less는 오름차순, greater는 내림차순을 나타냅니다. 기본적으로 우선순위 큐의 비교 연산자는 내림차순으로 설정되어 있습니다. 따라서 오름차순으로 우선순위 큐를 선언하고 싶으면 반드시 아래와 같이 명시해 주어야 합니다.priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq;이렇게 선언한 우선순위 큐를 초기화할 때 아래와 같이 범위 생성자를 사용하여 초기화할 수 있다는 점도 알아두시기 바랍니다.int arr1[] = {10, 20, 30};vector&lt;int&gt; v1 = {20, 10, 30};priority_queue&lt;int&gt; pq1(arr, arr+3);priority_queue&lt;int&gt; pq2(v1.begin(), v1.end());이외에 추가적인 특징으로 큐와 우선순위 큐 모두 반복자(iterator)가 존재하지 않고 원소에 개별적으로 접근할 수 없습니다. 오로지 queue는 front, back 멤버 함수, priority_queue는 top 멤버 함수만 사용할 수 있습니다.우선순위 큐에 존재하는 멤버 함수를 살펴보면 아래와 같습니다. empty : priority queue가 비어있는지 확인 size : priority queue의 크기를 확인 top : priority queue 내부의 제일 우선순위의 값을 출력 push : priority queue에 값을 삽입 emplace : priority queue에 구조를 삽입 pop : priority queue에서 제일 우선순위의 값을 제거 swap : 두개의 priority queue를 서로 swapReferences https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.htmlhttps://jungeu1509.github.io/algorithm/use-priorityqueue/" }, { "title": "알아두면 쓸모있는 C++ STL 정리 3", "url": "/posts/cpp-stl3/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-16 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.vector란? vector는 배열처럼 원소를 순서대로 저장하는 sequence container입니다. 그 중에서도 배열과 다르게 자동으로 메모리가 할당되고 삽입 삭제가 배열에 비해서 훨씬 쉽고 용이합니다. 그렇지만 vector도 배열 기반의 container이므로 삽입, 삭제가 자주 일어날 시 시간적인 측면에서 많은 비용이 소요됩니다.vector에 대한 일반적인 연산에 대한 복잡도는 다음과 같습니다. 임의 접근 (Random Access) = O(1) 벡터의 끝에 원소를 삽입하거나 삭제 = O(1) 원소의 삽입과 삭제 = O(n)  (마지막 원소로부터의 거리에 비례) vector를 사용하기 위해서는 &lt;vector&gt; 헤더 파일이 필요합니다. vector의 생성자는 아래와 같으며, 아래와 같이 선언할 수 있습니다.vector&lt;type&gt; v; //빈 vector 생성vector&lt;type&gt; v(n); //n개의 0으로 초기화된 벡터 생성vector&lt;type&gt; v(n,m); //n개의 m으로 초기화된 벡터 생성vector&lt;type&gt; v2(v1); //v1 벡터를 복사한 v2 벡터 생성vector&lt;type&gt; v2(v1.begin(), v1.end()) //이터레이터를 통해 범위 생성자를 활용한 벡터 생성, 이터레이터가 있는 다른 컨테이너의 대입도 가능vector&lt;vector&lt;type&gt;&gt; v; //type형을 가지는 2차원 벡터 생성vector&lt;type&gt; v = {a1,a2,a3,...}; //{a1,a2,a3,...}으로 초기화된 벡터 생성지금부터는 vector의 다양한 멤버 함수들에 대하여 알아보겠습니다. v.assign(n,m)m으로 n개의 원소를 할당합니다. assign을 사용하게되면 벡터에 완전히 덮어씌워지게 됩니다. 즉 기존값은 완전히 사라지고 덮어씌우는 값만 남게됩니다. v.at(index)index에 위치한 원소를 반환합니다. 벡터 범위 내인지 유효성 검사를 하기 때문에 안전합니다. v[index]index에 위치한 원소를 반환합니다. 유효성 검사를 하지 않지만 속도가 빠릅니다. v.front()첫 번째 원소를 반환합니다. v.back()마지막 원소를 반환합니다. v.clear()모든 원소를 제거합니다. size는 줄어들지만 capacity(메모리 공간)은 그대로 남게 됩니다. v.push_back(m)마지막 원소 뒤에 원소 m을 삽입합니다. v.pop_back()마지막 원소를 제거합니다. v.resize(n)크기를 n으로 줄이거나 늘립니다. 커진 경우에는 빈 곳을 0으로 초기화합니다. v.resize(n,m)크기를 n으로 줄이거나 늘립니다. 커진 경우에는 빈 곳을 m으로 초기화합니다. v.insert(iter, m)iterator가 가리키는 위치에 m의 값을 삽입합니다. 그리고 나서 해당 위치를 가리키는 반복자를 반환합니다. v.insert(iter,k,m)iterator가 가리키는 위치부터 k개의 m을 삽입합니다. 다음 원소들은 다 뒤로 밀리게 됩니다. v.erase(iter)iterator가 가리키는 원소를 제거합니다. v.erase(begin iter, end iter)begin iterator부터 end iterator까지의 모든 원소를 제거합니다. v.empty()vector의 size, length가 0이면(비어 있으면) true를 반환하고 아닌 경우 false를 반환합니다. v.shrink_to_fit()capacity의 크기를 실제 vector의 size에 맞춥니다.vector 내 중복된 원소 제거 set이라는 컨테이너를 이용하면 중복된 원소를 알아서 제거해주긴 하는데 그 방법 말고 vector와 &lt;algorithm&gt; 헤더 파일 내의 unique라는 함수를 이용해서 간단하게 제거해볼 예정입니다. 먼저 unique 함수가 어떻게 동작하는지 아래의 코드를 통해 알아봅시다. template &lt;class ForwardIterator&gt;ForwardIterator unique(ForwardIterator first, ForwardIterator last){ if (first == last) return last; ForwardIterator result = first; while (++first != last) { if (!(*result == *first)) *(++result) = *first; } return ++result;} unique 함수는 시작 이터레이터와 끝 이터레이터를 넘겨 받고, 함수 내부적으로 result 이터레이터를 생성하여 최종적으로는 result 이터레이터를 반환해주는 구조입니다. 내부 로직을 보면 result 이터레이터에는 서로 다른 값의 원소만이 들어오게 됩니다. 하지만 이 가정은 우리가 인자로 넘긴 컨테이너의 원소들이 정렬되어 있는 상태이어야 한다는 것입니다. 이터레이터를 1칸씩 증가시키며 바로 뒤이은 원소하고만 비교하기 때문입니다. 즉 unique 함수를 이용해서 vector 내 중복된 원소를 제거하려면 우선 vector를 sort()등의 함수를 통해서 먼저 정렬 시켜주도록 합시다. 그 후 unique() 함수를 사용하게 되면 중복된 원소가 제거된 상태의 벡터(기존 벡터의 앞부분을 그대로 재활용함) 끝을 가리키는 이터레이터를 반환하게 됩니다. 띠라서 해당 이터레이터 부분부터 실제 벡터의 끝까지의 원소를 erase나 resize등의 함수를 통해 제거해주면 됩니다. 이 방법을 총 정리하면 아래와 같습니다.#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(void) { vector&lt;int&gt; v = { 1, 3, 2, 1, 8, 3, 5, 2, 6, 5, 8 }; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); for (int i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; ' ';}#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(void) { vector&lt;int&gt; v = { 1, 3, 2, 1, 8, 3, 5, 2, 6, 5, 8 }; sort(v.begin(), v.end()); vector&lt;int&gt;::iterator it; v.resize(unique(v.begin(), v.end()) - v.begin()); for (int i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; ' ';}반복자(iterator)란? 반복자는 컨테이너 내에서 포인터와 상당히 비슷한 개념입니다. 컨테이너에 저장된 원소들을 접근하고 참고할 때 사용합니다. 반복자는 컨테이너에 저장된 원소에 접근하고 순회하는 일반적인 방법을 제공합니다. 반복자는 아래와 같은 형식으로 선언할 수 있습니다. container::iterator 반복자는 기본적으로 begin()과 end()를 가집니다. 컨테이너 내에서 첫번째 원소를 가리키는 것이 iterator.begin()이고 마지막 원소의 다음을 가리키는 것이 iterator.end()입니다. 그래서 범위를 나타내보면 시작은 포함하지만 끝은 포함하지 않는 반 개방 범위이고 [begin(), end())로 범위를 표현할 수 있습니다. 이때 주의할 점이 원소가 없는 빈 컨테이너의 경우 begin()과 end()가 동일합니다. 따라서 우리는 모든 컨테이너에서 아래와 같은 반복문을 사용하여 모든 원소를 순회할 수 있습니다. for(iter = v.begin(); iter != v.end(); ++iter) { ...} 위에서 iter에 != 연산자를 사용했는데 이 연산은 모든 이터레이터에서 사용할 수 있습니다. random access 반복자인 경우 비교 연산까지 사용할 수 있습니다. 반복문에서 반복자를 증가시킬 때는 후위연산자보다는 전위연산자를 사용합니다. 후위 연산자를 사용하면 반복자의 이전 값을 반환하기 때문에 임시로 객체가 생겨 성능이 늦어집니다. 그러므로 가급적이면 전위연산자를 사용하도록 합시다.반복자와 관련된 표현은 아래와 같습니다. v.begin() : 컨테이너의 시작원소를 가리키는 반복자를 반환 v.end() : 컨테이너의 끝 표시 반복자를 반환 ++iter : 반복자가 다음 원소를 가리키도록 이동 *iter: iter가 가리키는 원소(객체)를 반환 iter[3] : iter+3번째 원소(객체)를 반환 iter += 2 : 현재 iter 위치에서 2개 뒤의 원소의 위치를 표현마지막으로 반복자의 종류에 대해서 알아봅시다. 반복자의 종류는 아래와 같이 총 5개이며, 종류에 따라 가능한 연산자에 제약이 있으니 꼼꼼히 확인하시길 바랍니다. 입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있는 반복자 (istream) 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자 (ostream) 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(–)이 가능한 반복자, !=, ==, ++, –연산 가능하다. (list, set, multiset, map, multimap) 임의 접근 반복자(random access iteraotr) : 양방향 반복자 기능에 +, -, ++, –, +=, -=, [], &lt;, &gt;, &lt;=, &gt;=, ==, != 연산이 가능한 반복자(vector, deque)모든 컨테이너는 양방향 반복자 이상을 제공합니다. 배열 기반 컨테이너인 vector와 deque는 임의 접근 반복자를 제공합니다.References https://rebro.kr/37https://inpages.tistory.com/135#recentEntries" }, { "title": "Purdue University 11th", "url": "/posts/purdue-11th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-07-15 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.프로젝트도 마무리 단계에 접어드는 이 시점에서 화목한 저희 팀의 모습 소개합니다.여기에 X라는 닉네임의 퍼듀 학생까지 모두 저희 팀입니다. 이 날은 X네 집에 초대 받아 맛있는 음식을 함께 먹었습니다.X는 멕시코계 미국인이라 멕시코 음식을 경험해 볼 수 있었습니다. 모두 너무 맛있었고 즐거운 시간이었습니다. 다음은 저희 집에 초대해서 한국식 식사를 대접하기로 했습니다." }, { "title": "알아두면 쓸모있는 C++ STL 정리 2", "url": "/posts/cpp-stl2/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-15 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.atoi(), atof(), atol()이란? 이번 포스팅에서는 문자열 관련된 내용을 위주로 다뤄보려고 합니다. 그 시작으로 atoi, atof, atol 함수들에 대하여 알아보겠습니다. atoi라는 함수 이름이 어떻게 지어졌는지 생각해보면 이해하기가 쉽습니다. a = char(ASCII), i = integer 로 보면 char(ASCII) to integer 라는 뜻으로 이해할 수 있습니다. 더 정확히 말하면 사실은 char* (C에서의 문자열을 나타내는 방식) to integer 입니다. 즉 C 스타일의 문자열을 int, double(float), long형으로 변환시켜주는 함수입니다. C++이 아닌 C 언어에서는 문자열을 나타내기 위해 char*와 같은 데이터 타입을 사용합니다. 반면에 C++에서는 string을 많이 사용합니다. 이번 파트에서 말하는 것은 C 스타일의 문자열임을 반드시 명심하시길 바랍니다. string을 다양한 숫자 타입으로 변환시켜주는 함수는 stoi, stof, stol 등으로 따로 존재합니다.위 함수는 C++ 기준 &lt;cstdlib&gt;라는 헤더에 존재합니다. 사용 예제는 아래와 같습니다. char cStr[10] = \"2022\";int num;num = atoi(cStr); //char* 형의 C 스타일의 문자열이 integer로 변환 위 문자열은 숫자로만 이루어져 있어서 정수형으로의 변환이 문제되지 않을 것 같은데, 만약 숫자가 아닌 문자들이 문자열 내에 혼재한다면 어떻게 되는지도 알아보겠습니다. 결론부터 말하자면 atoi()는 매개변수로 들어온 문자열을 앞에서 부터 읽어서, “공백 혹은 숫자가 아닌 문자”가 나올 때까지 숫자로 변환시켜주는 원리 입니다. 처음부터 공백 혹은 숫자가 아닌 문자를 만나면 0을 리턴합니다. 즉 아래와 같이 출력됩니다. char cStr1[10] = \"Logan\"; //처음부터 숫자가 아닌 문자를 만나므로 0을 리턴char cStr2[10] = \"2022Logan\"; //처음엔 숫자를 만나고 그 뒤 문자를 만나므로 숫자까지만 변환하여 2022 리턴char cStr3[10] = \"Logan2022\"; //처음부터 숫자가 아닌 문자를 만나므로 0을 리턴 char* -&gt; string, string -&gt; char* 이번에는 char*(C 스타일의 문자열)을 string(C++ 스타일의 문자열)로 바꾸는 방법과 그 반대의 방법 또한 알아보도록 하겠습니다. char* -&gt; string char* cStr = \"Logan\";string cppStr = cStr; 위처럼 string 객체를 만들면서 char*의 포인터 값으로 초기화 시켜주면 됩니다. string -&gt; char* string cppStr = \"Logan\";const char* cStr = cppStr.c_str(); 위처럼 &lt;cstdlib&gt; 헤더 파일 내에 존재하는 c_str() 메소드를 사용할 수 있습니다. 여기서 주의할 점으로 c_str() 함수의 리턴값은 const char* 타입으로, 내용을 변경할 수 없는 C 스타일의 문자열 타입이라는 것을 기억하시길 바랍니다. stoi(), stof(), stol()이란? 사실 지금까지는 stoi, stof, stol 함수를 설명하기 위한 빌드업 이었습니다. C++ 11버전 이전에는 string을 integer, float, long 등의 타입으로 변환하기 위해서 string을 c_str() 함수를 거쳐 C 스타일의 char* 문자열로 먼저 바꾸고 난 뒤 char* 문자열을 atoi 함수를 거쳐 integer로 바꾸는 복잡한 과정을 진행했어야 하는데 C++ 11버전이 업데이트 되면서 하나의 함수로 쉽게 변환할 수 있게 되었습니다. 그럼 먼저 이 함수들의 원형을 살펴보겠습니다. 이 함수는 정수형인 int, long형과 실수형인 float,double형의 원형으로 나뉩니다. 참고로 위 함수들을 사용하려면 &lt;string&gt; 헤더 파일이 필요합니다. 정수형 원형 int stoi(const string&amp; str, size_t* idx = 0, int base = 10)long stol(const string&amp; str, size_t* idx = 0, int base = 10) 실수형 원형 float stof(const string&amp; str, size_t* idx = 0)double stod(const string&amp; str, size_t* idx = 0) 원형 내 파라미터들은 복잡해보이지만 디폴트 값이 설정되어 있기 때문에 사실 기본적인 사용법은 아래와 같이 간단합니다. string stringint=\"2022\";string stringlong=\"202220222022\";string stringfloat=\"3.14\";string stringdouble=\"2.022\";int numint = stoi(stringint);long numlong = stol(stringlong);float numfloat = stof(stringfloat);double numdouble = stod(string);이제 그러면 조금 더 복잡하게 매개변수들을 조금 더 활용한 응용 사용법을 알아보겠습니다.string str1 = \"22Logan\";size_t sz;int num2 = stoi(str1, &amp;sz);cout &lt;&lt; num2 &lt;&lt; endl; //처음엔 숫자를 만나고 그 뒤 문자를 만나므로 숫자까지만 변환하여 22 출력cout &lt;&lt; sz &lt;&lt; endl; //숫자가 아닌 첫 문자가 나오는 index를 담고 있게 되므로 L이 위치한 2 출력cout &lt;&lt; str1[sz] &lt;&lt; endl; //str1[2]와 같은 의미 이므로 L 출력cout &lt;&lt; str1.substr(sz) &lt;&lt; endl; //str1의 index 2부터 끝까지의 부분 문자열을 출력하므로 Logan 출력 즉, 위 예제를 정리해보면, 단순히 string to integer 뿐만 아니라, stoi를 통해서 (숫자+문자)로 이루어진 string을 숫자와 문자로 쉽게 나눌 수 있습니다. 하지만 반대로 (문자+숫자)인 경우에는 위처럼 stoi를 활용하기가 어려울 것입니다. string이 처음부터 문자로 구성되어 있다면 sz에 0이 들어갈 것이기 때문입니다.다음으로는 한층 더 나아가 정수형 원형에서의 마지막 파라미터인 base(진법) 사용법도 알아보겠습니다.string str2 = \"\";str2 = \"1110\";cout &lt;&lt; stoi(str2, nullptr, 2) &lt;&lt; endl; //str2는 2진수인데 int로 변환해달라는 의미. 따라서 14 출력str2 = \"014\";cout &lt;&lt; stoi(str2, nullptr, 8) &lt;&lt; endl; //str2는 8진수인데 int로 변환해달라는 의미. 따라서 12 출력str2 = \"0x14\";cout &lt;&lt; stoi(str2, nullptr, 16) &lt;&lt; endl; //str2는 16진수인데 int로 변환해달라는 의미. 따라서 20 출력to_string()이란? 이번엔 정확히 위와 반대로 int, float, long 등의 숫자 데이터 타입을 string으로 바꿔주는 to_string에 대하여 알아보겠습니다.굉장히 간단합니다. to_string(숫자)의 꼴로 사용하면 됩니다. 이를 사용하기 위해서 &lt;string&gt; 헤더 파일을 포함시켜야 합니다.int num1 = 2022;float num2 = 20.22f;string str1 = to_string(num1);cout &lt;&lt; str1 &lt;&lt; endl; //2022 출력string str2 = to_string(num2);cout &lt;&lt; str2 &lt;&lt; endl; //20.220000 출력string 클래스 이번 부분에서는 string 클래스와 관련해서 총 정리를 하려고 합니다. 우선 string 클래스를 사용하려면 &lt;string&gt; 헤더 파일이 필요합니다. string은 C 문자열 스타일 char*, char[]과 다르게 문자열의 끝에 ‘\\0’이 들어있지 않습니다. 그말인 즉슨 C 문자열 끝에는 ‘\\0’이 반드시 들어가 있어야 합니다. str1.at(index)string 인자에 접근하는 메소드입니다. 뒤에 나올 [] operator와 다르게 string 인덱스 범위를 초과하여 접근하는지를 검사하여 잘못된 인덱스에 접근을 하면 오류를 내뱉어 줍니다. 이러한 점은 프로그래머의 디버깅에 도움이 될 것입니다. str1[index][] operator를 사용하여 string 인자에 접근합니다. 위에서 언급했던 것처럼 []는 잘못된 인덱스에 접근하더라도 오류를 내뱉지 않고 실제로 접근해 버립니다. 위와 같은 인덱스 범위 검사를 하지 않기 때문에 속도가 빠르다는 장점이 있지만 추후에 디버깅하기 어럽게 만듭니다. str1.front() string의 맨 앞 인자를 반환합니다. str1.back()string의 맨 뒤 인자를 반환합니다. str1.size(), str1.length()string의 사이즈 및 길이를 반환합니다. 두 값은 실제 인자 요소의 개수이며 같은 값입니다. str1.capacity()string 객체에 할당된 실제 메모리 크기를 반환합니다. str1.resize(n)string 크기를 n으로 줄입니다. 이 과정에서 기존 크기보다 작게 줄여지면 줄어든 뒷 데이터 부분은 버려지게 되고 기존 크기보다 늘어나면 공백으로 채웁니다. str1.resize(n,’c’)처럼 사용하면 ‘c’라는 문자로 빈공간을 채우게 됩니다. str1.clear()string에 들어있는 문자열을 지웁니다. capacity는 그대로 남습니다. str1.empty()string의 size, length가 0인지 확인하여 비어있으면 true, 차있으면 false를 리턴합니다. str1.c_str()string 객체를 C 스타일의 문자열로 바꿔줍니다. 이 과정에서 끝에 ‘\\0’도 알아서 채워줍니다. str1.substr(index,len)string 객체 내 index부터 시작해서 length의 길이를 가지는 부분 문자열을 리턴합니다. index는 0, len는 npos(-1로 언더 플로우 발생하여 문자열 최대 길이(끝까지))가 디폴트 값입니다. str1.replace(index,len,str)replace를 호출한 string(여기선 str1)의 index부터 시작해서 length 길이를 가지는 부분만큼을 파라미터 str 값 전체로 대체합니다. str1.compare(str)str1이 str에 비해서 사전순으로 빠르면 음수를 리턴하고 같으면 0, 느리면 양수를 리턴합니다. str1.copy(char*형 arr,len,index)C 스타일의 문자 배열에 str1의 index를 시작으로 len 길이만큼 복사해서 넣어줍니다. 여기서 주의할 점은 복사를 한 뒤에 char*형 arr 끝이 ‘\\0’으로 끝나는지 반드시 확인하여 아니라면 ‘\\0’을 끝에 넣어주도록 합니다. str1.find(str)파라미터 str이 str1에 있는지 찾는 함수입니다. 있다면 일치하는 부분의 첫번째 index를 반환하며, 없다면 string::npos를 반환합니다. str1.find(str,index)와 같이 사용하게 되면 str1의 index를 시작으로 str과 일치하는 부분이 있는지 찾게 됩니다. str1.push_back(‘c’)str1 맨 뒤에 문자 한개를 더하는 함수입니다. str1.pop_back()str1 맨 뒤 문자 한개를 없애는 함수입니다. str1.erase(index,len)str1의 index를 시작으로 len 길이만큼 문자를 제거합니다. swap(str1,str2)str1과 str2를 바꿉니다. 서로 참조를 교환해서 스왑하는 방식이라 성능 저하를 걱정할 필요가 없습니다. isalpha(), isdigit()이란? isalpha는 알파벳 문자인지 확인해주는 함수이며 isdigit은 0~9의 숫자인지 판단해주는 함수입니다. 이 두 함수 모두 C++ 기준 &lt;cctype&gt;이라는 헤더 파일 내에 존재합니다. 함수의 원형은 아래와 같습니다. int isdigit(int c); //0~9의 숫자가 들어오면 0이 아닌 숫자(true)를 리턴하고 아닌 경우에는 0(false) 리턴int isalpha(int c); //'A'~'Z'의 대문자는 1을 리턴, 'a'~'z'는 2를 리턴, 알파벳이 아닌 경우에는 0을 리턴 먼저 isdigit에 대하여 자세히 알아보면, 숫자 0~9는 아스키 코드로 48~57에 매칭이 되는데 이러한 숫자가 들어오면 0이 아닌 숫자(true)를 리턴하고 아닌 경우 0(false)를 리턴합니다.isalpha의 경우에는 ‘A’~’Z’의 대문자는 1을 리턴, ‘a’~’z’는 2를 리턴, 알파벳이 아닌 경우에는 0을 리턴합니다. 아스키 코드상에서 ‘A’~’Z’는 65~90에 매칭되고 ‘a’~’z’는 97~122에 매칭됩니다.References https://blockdmask.tistory.com/338https://blockdmask.tistory.com/448https://blockdmask.tistory.com/362" }, { "title": "알아두면 쓸모있는 C++ STL 정리 1", "url": "/posts/cpp-stl/", "categories": "Computer science, Algorithm", "tags": "알고리즘, 코딩 테스트, C++, STL", "date": "2022-07-14 00:00:00 +0900", "snippet": "알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.map이란? map을 사용하기 위해서는 #include &lt;map&gt; 헤더 처리를 해줘야 합니다. map은 &lt;key, value&gt;의 쌍으로 이루어져있으며 기본적으로 선언은 아래와 같이 합니다. map&lt;int, string&gt; map1; 맵은 레드-블랙 이진트리로 구현되어 있어 검색,삽입,삭제 속도가 O(log n)으로 빠릅니다. 또한 자동으로 key 값에 대한 오름차순으로 정렬되게 되고 동적할당 됩니다. unodered_map의 경우에는 정렬되지 않습니다. 만약 오름차순이 아닌 내림차순으로 정렬되게 하고 싶다면 아래와 같이 선언하면 됩니다. map&lt;int, string, greater&lt;int&gt; &gt; map1; 그리고 map에서 Key값은 중복되지 않습니다. Key값을 중복해서 사용하고 싶다면 multimap을 사용해야 합니다. map에서 value를 빼고 key로만 구성한 Set이라는 컨테이너도 이와 굉장히 유사한데 Set에 대해서는 다음에 더욱 자세히 살펴 보도록 하겠습니다.map을 사용하기 위해 우선, 어떻게 데이터를 넣을 수 있는지 insert 멤버 함수에 대하여 알아봅시다. insert에는 아래와 같이 총 5개의 방법이 존재합니다. map1.insert({\"key1\",200}); //C++ 컴파일러 11 버전 이상부터 지원하는 {} 연산 map2.insert(pair&lt;int, string&gt;(50,\"로건\")); //pair&lt;&gt; 사용map3.insert(map2.begin(), map2.end()); // 범위를 통한 삽입, 여기선 map2에 속하는 원소 처음부터 끝까지 모두 복사, 범위는 [map2.begin(), map2.end()) 임에 주의map4.insert(make_pair(\"key2\",400)); //make_pair() 사용map5[\"key3\"] = 600; 위 멤버 함수들에 대한 자세한 설명은 주석으로 대체하도록 하겠습니다. 그중에서 pair 및 {}와 관련된 설명은 아래에서 별도로 자세히 설명하겠습니다. insert 함수에서 놓치지 말아야할 것은 리턴값입니다. insert 멤버 함수는 리턴 타입 &lt;iterator, bool&gt;을 리턴합니다. iterator는 insert가 된 pair의 위치를 나타내게 되고, bool은 insert가 정상적으로 되었는지 안되었는지 부울값으로 나타내게 됩니다. 만약, 넣고자하는 key값이 이미 해당 map에 존재했다면 false 값이 들어있을 것 입니다. 이러한 리턴값 역시 알고리즘 풀이에 있어서 좋은 소스로 활용될 수 있으니 위 내용을 잘 기억할 수 있도록 합니다.이제 그러면 삭제와 관련된 멤버 함수 erase에 대하여 알아보겠습니다. map1.erase(\"key1\"); //key값 그 자체를 사용하여 한개의 원소 삭제 map1.erase(map1.find(\"key1\")); //이터레이터를 통해 한개의 원소 삭제map1.erase(map1.find(\"key1\"), map1.find(\"key5\")); //key1,key2,key3,key4,key5의 순서로 map에 저장되어 있다면 범위가 [key1, key5) 이므로 key1, key2, key3, key4가 삭제되게 된다 위와 같이 erase는 iterator를 매개변수로 넣어 사용합니다.이 외에도 유용한 멤버 함수 몇가지를 정리해보자면 아래와 같습니다. map1.empty(); //map의 원소가 0개이면 true를 리턴 그 외는 false 리턴map1.clear(); //map의 모든 원소 삭제map1.find(\"key1\"); //key1을 key로 가지는 원소의 iterator를 반환, 없으면 map1.end() iterator를 반환map1.lower_bound(\"key3\"); //key3을 기준으로 key값이 같거나 큰 원소를 기준으로 가장 왼쪽에 있는(그중에서 가장 작은) iterator를 리턴 map1.upper_bound(\"key3\"); //key3을 기준으로 key값이 큰 원소를 기준으로 가장 왼쪽에 있는(그중에서 가장 작은) iterator를 리턴 pair&lt;&gt;, make_pair() 그리고 {} 위에서 배웠던 것처럼 map은 &lt;key, value&gt;의 쌍으로 이루어져 있습니다. 이를 담기위해 쓰는 것이 pair&lt;&gt;, make_pair() 그리고 {} 입니다. pair&lt;int, string&gt;(50,\"로건\");make_pair(\"key2\", 400);{\"key1\", 200}; 위 예시에서 볼 수 있듯이 pair는 &lt;&gt;안에 자료형을 명시해줘야만 합니다. 이와 다르게 make_pair는 자료형을 명시해주지 않더라도 컴파일러가 유추하여 인지하게 됩니다. {}는 최신 컴파일러 버전인 11버전 이상부터 사용할 수 있는데 make_pair를 더 간단하게 만든 버전이라고 생각하시면 될 것 같습니다. 여기서 주의할 점은 위 예시들은 pair 변수 등에 들어갈, 혹은 pair 타입을 쓰는 파라미터의 값으로 들어갈 pair 상수라는 점입니다. pair 변수를 생성하려면 아래와 같이 선언해야함을 헷갈리지 않길 바랍니다. pair&lt;int, string&gt; pair1(50,\"로건\"); //pair1이 pair 타입을 가지는 변수 이름, 변수 선언과 동시에 값으로 초기화 References https://ssocoit.tistory.com/25" }, { "title": "Purdue University 10th", "url": "/posts/purdue-10th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-07-08 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.이번 포스팅은 시카고 여행의 마지막 포스팅입니다.시카고의 야경은 정말 너무 아름답습니다. 가서 가만히 앉아만 있어도 시간이 정말 잘 갑니다.사진에 진심인 우리들과 함께라면…날이 더워서 이 날도 스타벅스를 정말 많이 갔습니다. 그 중에서도 여기는 엄청 크다고 알려진 시카고의 reserve 매장입니다. 알코올과 섞인 커피도 판매하고 빵의 종류도 엄청 많고 맛있습니다.그 후, 한국에도 있고 세계적으로도 맛있다고 소문난 울프강 스테이크 집에 가서 식사를 했습니다. 기대를 많이 해서 그런지 맛은 무난했습니다.소중한 사람들과 좋은 장소에 함께여서 더욱 행복했던 시카고 여행 끝." }, { "title": "Purdue University 9th", "url": "/posts/purdue-9th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-07-01 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.이번 포스팅부터 다음 포스팅까지는 시카고 여행 사진 모음집이 게시될 예정입니다.저희는 룸메이트 + 셀리 친구와 함께 직접 차를 빌려 시카고로 1박 2일 여행을 떠났습니다. 시카고는 정말 최고의 여행지였습니다.이번 저희의 숙소인 힐튼 호텔에 체크인 먼저 해줍니다.친구들과 사진도 많이 남기고 좋은 곳에도 많이 다녀왔습니다. 짧은 1박2일의 일정이었지만 정말 알차고 빠듯하게 보내며 즐길 것은 다 즐기고 온 것 같습니다.이렇게 맛있는 음식들도 많이 먹었습니다." }, { "title": "Purdue University 8th", "url": "/posts/purdue-8th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-06-24 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.드디어 기다리고 기다리던 퍼듀 학생증이 나왔습니다. 퍼듀 학생증이 있어야 캠퍼스 내 다이닝 코트를 이용할 수 있었기에 이 카드를 정말 오래 기다렸습니다. 하지만 카드가 나온 뒤에도 다른 모든 학생들이 카드가 나올 때까지 기다린 뒤 사용 가능했습니다.그래서 이번에도 점심은 밖에서 교수님과 학생들과 다같이 스시&amp;롤 집에 갔습니다. 가격대는 좀 있지만 맛은 매우 좋았습니다. 계속 가고 싶은 맛그 후 저녁은 룸메이트들과 마라샹궈 맛집 블레이즈에 갔습니다. 캠퍼스 내에 인기있는 중식당입니다.그렇게 식사를 마친 뒤에는 학교에서 지원해준 영화 티켓을 들고 생전 처음 미국 영화관에 갔습니다. 오늘 볼 영화는 이제 막 개봉한 닥터 스트레인지! 원래 마블 영화를 잘 안보지만 매우 재밌었습니다." }, { "title": "Introduction to Docker", "url": "/posts/introduction-to-docker/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, google cloud platform, docker, 인프라, 클라우드, 구글 클라우드 플랫폼, 도커", "date": "2022-06-24 00:00:00 +0900", "snippet": "이번 포스팅에서는 GCP(Google Cloud Platform) 상에서 도커를 활용하는 방법에 대하여 배워보도록 하겠습니다. 도커에 대한 기본 개념이 부족한 분들에게도 도움이 될 것이라고 생각합니다.Docker란? Docker는 컨테이너를 기반으로 하는 오픈소스 가상화 플랫폼입니다. 쉽게 말해 컨테이너 기반으로 어플리케이션을 작성하고 동작할 수 있게 해줍니다. 이렇게 만들어진 컨테이너는 시스템 환경에 구애받지 않고 도커 엔진만 있다면 어디서든 동일하게 실행시킬 수 있습니다. 이것이 컨테이너의 큰 장점입니다.Docker 실습 예제, Hello World 모든 프로그래밍의 기초 예제라고 할 수 있는 Hello World 예제를 통해 도커의 흐름을 알아보도록 하겠습니다. GCP Cloud Shell을 열고 아래의 명령어를 입력해봅니다. docker run hello-world 그러면 아래와 같은 출력 결과가 나오는데, 이를 통해 다음을 알 수 있습니다. Unable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world9db2ca6ccae0: Pull completeDigest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... docker daemon이 hello-world 이미지를 찾아봤지만 찾을 수 없었고, 그래서 Docker Hub라는 public registry에서 hello-world 예제 이미지를 pull 해오게 됩니다. 그렇게 받아온 이미지를 바탕으로 docker container를 만들게 되고 그 컨테이너를 실행하게 된 것입니다. docker image가 정상적으로 생성됐는지 아래 명령어를 통해 확인할 수 있습니다. docker images 그리고 아래 명령어를 통해 docker container를 실행시킬 수 있습니다. hello-world 라는 이미지로부터 컨테이너를 실행시킨다는 의미입니다. docker run hello-world 우리는 초기에 hello-world 실행시켰기 때문에 이미 pull 받은 이미지가 있어서 local 환경에서 해당 이미지를 바로 찾을 수 있습니다. 따라서 DockerHub에서 이미지를 불러오는 과정이 생략됩니다. 위 명령어를 통해 만들어진 이미지는 아래 명령어를 통해 현재 실행중인 컨테이너 목록들을 확인할 수 있습니다. docker ps 하지만 정작 위 명령어를 실행해보면 실행되고 있는 컨테이너가 하나도 없음을 확인할 수 있습니다. 사실 hello-world 컨테이너는 이미 실행되고 끝났기 때문에 확인할 수 없는 것입니다. 이미 실행되고 끝나버린 컨테이너도 확인할 수 있는 명령어는 다음과 같습니다. docker ps -a Docker build 테스트 환경을 구성하기 위해 우선 아래처럼 test 디렉토리를 만들고 해당 디렉토리로 이동해 줍니다. mkdir test &amp;&amp; cd test 그 후 Dockerfile을 아래와 같이 생성해줍니다. cat &gt; Dockerfile &lt;&lt;EOF# Use an official Node runtime as the parent imageFROM node:lts# Set the working directory in the container to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Make the container's port 80 available to the outside worldEXPOSE 80# Run app.js using node when the container launchesCMD [\"node\", \"app.js\"]EOF 각 line에 대한 설명은 주석으로 대체하도록 하겠습니다. 그 후 테스트용 node application을 실행해보기 위해서 app.js를 아래와 같이 만들어 줍니다. cat &gt; app.js &lt;&lt;EOFconst http = require('http');const hostname = '0.0.0.0';const port = 80;const server = http.createServer((req, res) =&gt; { res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');});server.listen(port, hostname, () =&gt; { console.log('Server running at http://%s:%s/', hostname, port);});process.on('SIGINT', function() { console.log('Caught interrupt signal and will exit'); process.exit();});EOF 이제 미리 정의한 Dockerfile을 바탕으로 도커 이미지를 빌드할 차례입니다. 아래 명령어에 -t 플래그는 태그를 설정하는 플래그입니다. name:tag의 쌍으로 설정할 수 있습니다. 만약에 tag를 지정하지 않는다면 default로 latest라는 태그가 붙게 됩니다. docker build -t node-app:0.1 . 이렇게 빌드한 이미지는 아래 명령어를 통해 확인해볼 수 있습니다. docker images 위 명령어를 실행한 결과는 아래와 같습니다. REPOSITORY TAG IMAGE ID CREATED SIZEnode-app 0.1 f166cd2a9f10 25 seconds ago 656.2 MBnode lts 5a767079e3df 15 hours ago 656.2 MBhello-world latest 1815c82652c0 6 days ago 1.84 kB 여기서 신기한 점을 확인해볼 수 있습니다. Dockerfile에서 FROM을 통해 지정한 node라는 이름의 base image까지 설치되어 있는 것을 확인해 볼 수 있습니다. 말 그대로 이건 base image이기 때문에 node-app 이미지를 지운 뒤에야 base image인 node image를 제거할 수 있습니다.Docker run 그럼 이제 위에서 build한 이미지를 기반으로 컨테이너를 run 시켜봅시다. docker run -p 4000:80 --name my-app node-app:0.1 위 명령어를 통해 이미지를 바탕으로 컨테이너를 실행시킬 수 있습니다. 위에서 사용된 플래그에 대해서 자세히 알아보자면, name 플래그를 통해서 컨테이너 이름을 지정 할 수 있습니다. 또한 port 플래그는 호스트의 4000번 포트를 컨테이너를 외부에 노출 시킬 80포트와 매핑하는 것을 의미합니다. 컨테이너 실행이 정상적으로 되었는지 확인해보기 위해 curl 명령어를 통해 http request를 보내볼 수 있습니다. 하지만 위처럼 실행을 하면 명령어를 실행시킨 터미널이 켜져있을 때 까지만 컨테이너가 돌아가게 되고 터미널을 끄면 함께 종료됩니다. 이를 방지하기 위해 백그라운드에서 실행을 하고 싶다면 -d 플래그를 함께 적어주면 됩니다. curl http://localhost:4000 이렇게 만든 컨테이너의 실행을 멈추고 제거하고 싶다면 아래 명령어를 사용하면 됩니다. docker stop my-app &amp;&amp; docker rm my-app Docker debug docker logs 명령어를 통해서 컨테이너의 로그를 확인할 수 있습니다. docker logs -f [container_id] 실행중인 컨테이너에 bash로 접근하고 싶다면 docker exec 명령어를 사용하면 됩니다. docker exec -it [container_id] bash 컨테이너의 metadata를 확인할 수 있는 명령어는 docker inspect입니다. docker inspect [container_id] Docker publish 이미지를 Cloud에 배포하여 필요할 때 pull 받아 사용할 수 있습니다. 이를 위해 GCR(Google Container Registry)을 사용할 예정입니다. GCR에 이미지를 푸시하기 위해서는 먼저, [hostname]/[project-id]/[image]:[tag]와 같은 format으로 태그를 해줘야 합니다. docker tag node-app:0.2 gcr.io/[project-id]/node-app:0.2 태그를 해준 뒤 아래 명령어를 통해 GCR에 push 해 줄 수 있습니다. docker push gcr.io/[project-id]/node-app:0.2 GCR의 푸시된 이미지는 “Google cloud 상에 Container Registry”에서 확인할 수 있습니다. 이제부터는 GCR의 이미지를 pull 받아서 정상적으로 작동하는지 테스트를 해보겠습니다. 이를 위해 기존에 설치되어 있던 도커 이미지와 컨테이너를 모두 제거해주는 작업을 먼저 해주도록 하겠습니다. 우선 컨테이너의 실행을 멈추고 삭제하는 명령어입니다. docker stop $(docker ps -q)docker rm $(docker ps -aq) 다음은, 순차적으로 도커 이미지를 제거해주는 명령어입니다. docker rmi node-app:0.2 gcr.io/[project-id]/node-app:0.2 node-app:0.1docker rmi node:ltsdocker rmi $(docker images -aq) # remove remaining imagesdocker images 기존에 존재하던 도커 이미지와 컨테이너가 모두 제거되었으므로 GCR로부터 이미지 pull을 받고 테스팅 해보도록 합니다. docker pull gcr.io/[project-id]/node-app:0.2docker run -p 4000:80 -d gcr.io/[project-id]/node-app:0.2curl http://localhost:4000 References https://cloud.google.com/https://www.cloudskillsboost.google/focuses/1029?parent=catalog" }, { "title": "Network and HTTP Load Balancers 구성", "url": "/posts/load-balancer-setting/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, google cloud platform, network load balancer, HTTP load balancer, 인프라, 클라우드, 가상머신, 구글 클라우드 플랫폼, 네트워크 로드 밸런서, HTTP 로드 밸런서", "date": "2022-06-21 00:00:00 +0900", "snippet": "이번 포스팅에서는 잠시 도커와 쿠버네티스를 내려놓고 GCP(Google Cloud Platform)에서 제공하는 Network load balancer와 HTTP load balancer에 대하여 알아보고 어떻게 구성할 수 있는지 실습과 함께 배워 보도록 하겠습니다.로드 밸런서란? 로드 밸런서(load balancer)라는 이름에서 알 수 있듯이 부하를 분산시켜주는 역할을 합니다. 대규모 트래픽이 하나의 Instance에 집중적으로 들어오게 되면 우리는 당연스럽게도 병목 현상에 대하여 걱정할 것입니다. 이러한 문제들을 해결하고 서비스의 안정성과 신뢰성 등을 높이기 위해 load balancer를 사용합니다. GCP에서 제공해주는 다양한 로드 밸런서들이 있지만 그 중에서도 네트워크 계층 내 Layer 4 기반의 네트워크 로드 밸런서와 Layer 7 기반의 http 로드 밸런서에 대하여 공부해 보도록 하겠습니다.Default compute zone 및 region 설정 이전 포스팅을 계속해서 봐오셨던 분들은 이제 zone과 region의 개념에 대해서 충분히 익숙할 것이라고 생각합니다. 앞으로 실습을 통해 만들어질 instances들이 위치할 default zone과 region을 아래와 같이 설정해 줍니다. gcloud config set compute/zone us-central1-agcloud config set compute/region us-central1 다수의 web server instances 생성 로드 밸런싱의 효과를 테스트하기 위해 먼저 로드 밸런싱의 대상이 될 다수의 web server instances를 생성해주도록 하겠습니다. 총 3개의 compute engine virtual machines을 만들 것이며 그리고 해당 인스턴스에 Apache를 설치한 뒤, http traffic이 각각의 인스턴스들에 도달할 수 있도록 방화벽 규칙을 설정해 주도록 하겠습니다.우선, 아래 명령어를 통해 총 3개의 인스턴스를 만들어줄 것인데 추후에 방화벽 설정을 1개의 태그를 통해 쉽게 하기 위해 동일한 태그를 적용하여 묶어주겠습니다. 그 후 각 인스턴스가 시작될 때 다음과 같은 흐름을 가지는 스크립트를 실행하도록 하였습니다.“apache를 설치하고 테스트용 html 파일을 터미널에 출력한 뒤 해당 내용을 /var/www/html/index.html에 저장” gcloud compute instances create www1 \\ --image-family debian-9 \\ --image-project debian-cloud \\ --zone us-central1-a \\ --tags network-lb-tag \\ --metadata startup-script=\"#! /bin/bash sudo apt-get update sudo apt-get install apache2 -y sudo service apache2 restart echo '&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;www1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;' | tee /var/www/html/index.html\" gcloud compute instances create www2 \\ --image-family debian-9 \\ --image-project debian-cloud \\ --zone us-central1-a \\ --tags network-lb-tag \\ --metadata startup-script=\"#! /bin/bash sudo apt-get update sudo apt-get install apache2 -y sudo service apache2 restart echo '&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;www2&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;' | tee /var/www/html/index.html\" gcloud compute instances create www3 \\ --image-family debian-9 \\ --image-project debian-cloud \\ --zone us-central1-a \\ --tags network-lb-tag \\ --metadata startup-script=\"#! /bin/bash sudo apt-get update sudo apt-get install apache2 -y sudo service apache2 restart echo '&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;www3&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;' | tee /var/www/html/index.html\" 그 후 생성된 각각의 인스턴스들에 http 트래픽이 닿을 수 있도록 아래와 같이 방화벽 규칙을 설정해 줍니다. gcloud compute firewall-rules create www-firewall-network-lb \\ --target-tags network-lb-tag --allow tcp:80 정상적으로 설정되었다면, 아래 명령어를 통해 생성된 인스턴스들의 외부 IP를 확인하고 curl 명령을 통해 인스턴스들이 정상 동작중인지 확인해 봅니다. gcloud compute instances listcurl http://[위에서 확인한 외부 IP] Network load balancer 구성 지금부터 본격적으로 네트워크 로드 밸런서를 구성해 볼텐데, 로드 밸런서를 구성할 때 각각의 가상 머신들은 자신이 설정한 정적 외부 IP 주소(static external IP address)를 통해 패킷들을 전달 받게 됩니다. Compute engine image로 만들어진 인스턴스들은 이 IP를 처리하도록 자동으로 구성됩니다. 우선 다음 명령어를 통해 정적 외부 IP 주소를 생성해 주도록 하겠습니다. gcloud compute addresses create network-lb-ip-1 \\ --region us-central1 그 후 http health check resource과 동일한 지역의 인스턴스들의 묶음인 target-pool을 생성하고 이 pool에 health check를 적용해 줍니다. gcloud compute http-health-checks create basic-checkgcloud compute target-pools create www-pool \\ --region us-central1 --http-health-check basic-check 위에서 생성한 pool에 아까 생성해두었던 3개의 인스턴스를 모두 추가해 줍니다. gcloud compute target-pools add-instances www-pool \\ --instances www1, www2, www3 그 후 forwarding rules까지 추가해주면 이로써 Layer 4 네트워크 로드 밸런서 설정 완료입니다. gcloud compute forwarding-rules create www-rule \\ --region us-central1 \\ --ports 80 \\ --address network-lb-ip-1 \\ --target-pool www-pool Network load balancer 테스트 위에서 구성한 Network load balancer을 테스트하기 위해 먼저 로드 밸런서에서 사용하는 forwarding rule의 외부 IP 주소를 확인해 줍니다. gcloud compute forwarding-rules describe www-rule --region us-central1 외부 IP 주소를 확인했다면 curl 명령어를 통해 아래와 같이 위에서 생성한 3개의 인스턴스로부터 어떻게 response가 오는지 확인해 봅니다. while true; do curl -m1 [위에서 확인한 외부 IP 주소]; done HTTP load balancer 구성 이번엔 Layer 4에 위치하는 네트워크 로드 밸런서가 아닌, Layer 7에 위치하는 HTTP 로드 밸런서를 구성해 보도록 하겠습니다. HTTP 로드 밸런서를 통해 URL 규칙 별로 보낼 인스턴스 설정할 수 있습니다. 또한, 사용자의 Request가 들어오면 항상 가장 가까우면서 충분한 Capacity를 가지고 있는 인스턴스로 라우팅 됩니다. Compute engine backend로 로드 밸런서를 구성하기 위해, Virtual machines들이 MIGs(managed instance groups) 안에 구성되어야 합니다. 이렇게 구성한 MIG은 외부 HTTP 로드 밸런서의 백엔드 서버를 실행시키는 가상 머신들을 제공합니다. MIG를 생성하기 전에 앞서서 아래 명령어를 통해 instance-templates를 만들어 줍니다. gcloud compute instance-templates create lb-backend-template \\ --region=us-central1 \\ --network=default \\ --subnet=default \\ --tags=allow-health-check \\ --image-family=debian-9 \\ --image-project=debian-cloud \\ --metadata=startup-script='#! /bin/bash apt-get update apt-get install apache2 -y a2ensite default-ssl a2enmod ssl vm_hostname=\"$(curl -H \"Metadata-Flavor:Google\" \\ http://169.254.169.254/computeMetadata/v1/instance/name)\" echo \"Page served from: $vm_hostname\" | \\ tee /var/www/html/index.html systemctl restart apache2' 이제 이 템플릿을 이용해 MIG를 만들어 줄 것입니다. MIG를 통해 동일한 여러 대의 VMs에서 어플리케이션을 동작시킬 수 있습니다. 또한, MIG는 autoscaling, autohealing, regional(multiple zone) deployment, and automatic updating 등의 자동화된 서비스를 제공합니다. 이러한 MIG 서비스를 이용하여 워크로드를 좀 더 가용성, 확장성 있게 만들어 줄 수 있습니다. 템플릿을 활용하여 MIG를 만드는 명령어는 아래와 같습니다. gcloud compute instance-groups managed create lb-backend-group \\ --template=lb-backend-template --size=2 --zone=us-central1-a 그 후 추후에 Google Cloud health checking systems를 사용하기 위해 트래픽을 허용하는 방화벽 수신 규칙을 생성해 줍니다. gcloud compute firewall-rules create fw-allow-health-check \\ --network=default \\ --action=allow \\ --direction=ingress \\ --source-ranges=130.211.0.0/22,35.191.0.0/16 \\ --target-tags=allow-health-check \\ --rules=tcp:80 이제 HTTP 로드 밸런서를 위한 인스턴스들이 준비되었으므로, 사용자들이 접근할 수 있도록 정적 외부 IP 주소를 생성해 줍니다. gcloud compute addresses create lb-ipv4-1 \\ --ip-version=IPV4 \\ --global 위에서 설정한 정적 외부 IP 주소는 아래 명령어를 통해 확인할 수 있습니다. gcloud compute addresses describe lb-ipv4-1 \\ --format=\"get(address)\" \\ --global 로드 밸런서에 health-check를 적용하기 위해 아래처럼 만들어줍니다. gcloud compute health-checks create http http-basic-check \\ --port 80 이제 로드 밸런서의 백엔드 서비스를 만들어준 뒤에 위에서 구성한 인스턴스 그룹을 해당 백엔드 서비스에 추가해줄 것입니다. gcloud compute backend-services create web-backend-service \\ --protocol=HTTP \\ --port-name=http \\ --health-checks=http-basic-check \\ --global gcloud compute backend-services add-backend web-backend-service \\ --instance-group=lb-backend-group \\ --instance-group-zone=us-central1-a \\ --global 사용자가 보내오는 요청을 위에서 만든 backend service로 라우팅하기 위해 URL map을 만들어 줍니다. gcloud compute url-maps create web-map-http \\ --default-service web-backend-service 이제 위에서 만든 URL map에 사용자 요청을 라우팅하기 위해 target HTTP 프록시를 만들어 줍니다. gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map-http 위 HTTP 프록시로 들어오는 사용자 요청에 대한 forwarding rule을 만들어주면 이로써 HTTP 로드 밸런서 구성이 끝이 납니다. gcloud compute forwarding-rules create http-content-rule \\ --address=lb-ipv4-1\\ --global \\ --target-http-proxy=http-lb-proxy \\ --ports=80 References https://cloud.google.com/https://www.cloudskillsboost.google/focuses/12007?locale=en&amp;parent=catalog" }, { "title": "GKE(Google Kubernetes Engine) Essentials", "url": "/posts/google-kubernetes-engine-essentials/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, google cloud platform, google kubernetes engine, kubernetes, docker, 인프라, 클라우드, 가상머신, 구글 클라우드 플랫폼, 구글 쿠버네티스 엔진, 쿠버네티스, 도커", "date": "2022-06-20 00:00:00 +0900", "snippet": "이번 포스팅은 GKE(Google Kubernetes Engine)을 처음 사용해보는 사용자들을 위해 기초적이고 핵심적인 부분만 다뤄보려고 합니다.GCP(Google cloud platform)에 대한 지식이 전혀 없다면 이전 포스팅인 Google cloud CLI 포스팅을 반드시 읽어본 뒤에 본 포스팅을 시작할 것을 추천드립니다.GKE(Google Kubernetes Engine)이란? GKE는 GCP 상에서 제공되는 구글 쿠버네티스 엔진으로 오랜 상업용 컨테이너 운영 경험의 노하우가 녹아있는 구글의 쿠버네티스 관련 서비스입니다. GKE는 구글 클라우드의 다양한 인스턴스 및 서비스 등을 기반으로 사용하며 이들이 주는 이점을 모두 누릴 수 있습니다. GCP가 주는 장점 몇가지를 살펴보면 다음과 같습니다. Load Balancing Node Pools Automatic scaling Automatic upgrades Node auto-repair Logging and Monitoring이러한 서비스들을 바탕으로 GKE는 Kubernetes cluster를 구성하는데 도움을 주고 이들을 효율적으로 관리하기 위한 다양한 기능들을 제공합니다. 지금부터는 이러한 GKE를 통해 컨테이너 어플리케이션을 어떻게 배포할 수 있는지 알아보도록 하겠습니다. Default compute zone 설정 이전 포스팅을 통해 Zone과 Region의 개념에 대해서 익히 들으셨을 것이라고 생각합니다. 혹시나 이에 대한 이해가 부족하다면, Google Cloud Platform Essentials 포스팅을 참고하시기 바랍니다. 우리는 앞으로 만들 우리의 Cluster와 그들의 resources가 위치할 디폴트 Zone을 아래와 같이 설정해 줄 수 있습니다. 여기서는 us-central1-a Zone을 선택하였습니다. gcloud config set compute/zone us-central1-a GKE cluster 생성 Cluster는 최소 1개 이상의 cluster master machine과 nodes라고 불리는 다수의 worker machines으로 이루어집니다. Virtual machine instances가 이러한 nodes로 역할하게 됩니다. GCP에서는 Compute Engine virtual machine instances를 활용하여 워커 노드를 구성합니다. 클러스터를 생성하기 위해서는 아래 명령어를 사용하면 됩니다. gcloud container clusters create [생성할 클러스터 이름] 수 분의 시간이 흐른 뒤, 생성이 완료되면 아래와 같은 출력 결과를 얻을 수 있을 것입니다. NAME: my-clusterLOCATION: us-central1-aMASTER_VERSION: 1.21.5-gke.1302MASTER_IP: 34.69.232.119MACHINE_TYPE: e2-mediumNODE_VERSION: 1.21.5-gke.1302NUM_NODES: 3STATUS: RUNNING Authentication credentials for cluters 얻기 클러스터를 생성한 뒤 해당 클러스터와 통신하려면 우리는 Authentication credentials, 즉 인증 자격 증명이 필요합니다. 우리가 접근하려는 클러스터의 이름을 사용하여 아래 명령어와 같이 자격 증명을 불러올 수 있습니다. gcloud container clusters get-credentials [접근할 클러스터 이름] 위 명령어를 실행한 뒤 아래와 같은 결과가 나오면 성공입니다. Fetching cluster endpoint and auth data.kubeconfig entry generated for my-cluster. Containerized application 클러스터 배포 이제 클러스터에 본격적으로 application을 배포할 수 있습니다. 우리는 그중에서도 컨테이너화된 어플리케이션을 배포해 보려고 합니다.아래 예시에서는 Container Registry 내에 존재하는 hello-app이라는 컨테이너 이미지를 배포합니다.그 전에 앞서서, GKE에서는 클러스터의 자원들을 관리하고 생성하기 위해서 아래와 같은 Kubernetes Object를 사용합니다. Deployment object: web server와 같은 stateless application을 배포하기 위해 사용 Service object: 배포할 application을 위한 규칙과 load banlancing을 정의하기 위해 사용우선, hello-app이라는 컨테이너 이미지로부터 hello-server라는 이름의 deployment object를 아래와 같이 생성해 보겠습니다. kubectl create deployment hello-server --image=gcr.io/google-samples/hello-app:1.0 아래와 같은 결과가 나왔다면 성공입니다. deployment.apps/hello-server created 다음으로 외부 트래픽에 우리의 어플리케이션을 노출시키기 위해 Kubernetes service object를 생성해 보겠습니다. kubectl expose deployment hello-server --type=LoadBalancer --port 8080 port flag를 통해 컨테이너가 노출될 포트를 지정해 주었고, 컨테이너를 위한 Load Balancer를 생성하도록 type flag를 설정해 주었습니다. 아래와 같은 결과가 나왔다면 성공입니다. service/hello-server exposed 클러스터 배포가 모두 성공적으로 이루어졌는지 확인하기 위해 아래 명령어를 사용할 수 있습니다. kubectl get service 위 명령어를 사용하면 아래와 같이 위에서 생성한 hello-server service가 생성되어 동작함을 확인할 수 있습니다. NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-server loadBalancer 10.39.244.36 35.202.234.26 8080:31991/TCP 65skubernetes ClusterIP 10.39.240.1 433/TCP 5m13s 위 결과에서 나온 hello-server의 EXTERNAL-IP를 바탕으로 http://[hello-server의 EXTERNAL-IP]:8080 브라우저를 통해 위 주소로 접속하게 되면 예제가 실행됨을 확인할 수 있습니다. GKE cluster 제거 위에서 생성한 클러스터를 제거하고 싶다면 아래와 같은 명령어 한 줄로 삭제할 수 있습니다. gcloud container clusters delete [지우고자 하는 클러스터 이름] References https://cloud.google.com/https://www.cloudskillsboost.google/focuses/878?parent=catalog" }, { "title": "Purdue University 7th", "url": "/posts/purdue-7th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-06-17 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.친구가 찍어준 아이패드 미러 샷… 저희는 이러고 놉니다.오늘은 저녁먹고 저희가 살고 있는 아파트 뒤에 있는 잔디밭에 놀러갔습니다. 뒤에 바로 호수가 있어서 저녁에 산책하기도 굉장히 좋습니다. 다만 벌레가 많다는 단점이 있습니다…여기 저기 같이 뛰어놀고 사진도 많이 찍다 왔습니다.다음날 학교에 출근한 뒤, 토니 교수님을 도와 퍼듀 대학교 야구장과 그랑프리 스타디움을 이어주는 무선 네트워크 망을 설치하였습니다. 토니 교수님은 네트워크 분야의 전문가이기 때문에 이렇게 옆에서 보고 배울 점이 참 많습니다.끝나고 먹은 웬디스 햄버거와 스타벅스…! 미국 햄버거는 다 맛있는 것 같습니다." }, { "title": "Purdue University 6th", "url": "/posts/purdue-6th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-06-10 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.미국에는 스타벅스가 곳곳에 참 많습니다. 물론 한국에도 참 많습니다만, 다른 카페에 비해서 압도적으로 많은 느낌입니다.그러한 미국 스타벅스에는 한국 스타벅스에 없는 음료도 많고 반대로 한국 스타벅스에는 있지만 미국 스타벅스에는 없는 음료도 많습니다.그 중에서도 한국에는 없는 음료 2가지를 소개하며 이번 주차 포스팅을 시작해보려고 합니다.이건 Dragon drink 입니다. 색깔이 참 이쁘죠. 말린 용과가 들어있는데 식감이 아주 좋고 맛있었습니다.이건 친구의 추천을 받아 마셔보게된 스트로베리 아사이 레모네이드입니다. 이게 알고보니까 한국에서도 출시 요청을 엄청 할 정도로 유명하고 맛있다고 들었습니다. 무작정 단 맛일 줄 알았는데 실제로 먹어보니 상큼하니 맛있었습니다.학교에서는 요즘도, 아직 Purdue 학생증이 안나와서 캠퍼스 안에 있는 프랜차이즈 식당에서 밥을 사먹고 있습니다. 이러한 식비 모두 지원을 받고 있습니다. 이번엔 점심에 Chick-fil-A라는 곳을 갔습니다. 치킨 버거가 메인입니다. 한국의 맘스터치가 생각납니다. 개인적으로 미국에서 가장 좋아하는 햄버거집 중 하나입니다.집에 돌아와서는 친구들과 저녁을 먹고 보드게임을 했습니다. 트위스터라는 몸으로 부딪혀가며 친해지는 게임인데 유명해서 아마 아시는 분들도 많이 계실 것 같습니다.그 다음으로는 펭귄 얼음 깨기 게임을 했습니다. 이 게임도 엄청 유명한 게임입니다. 시간 녹이기에 좋습니다. 그렇게 하루가 저물어 갑니다.다음날에는 미국에서 사귄 Megan네 집에 초대받아 놀러가는 날입니다. 서로가 각자의 고향 음식을 준비해오고 함께 나눠먹으며 즐기는 식입니다.저희는 삼겹살과 불닭볶음면 등을 준비해갔고 미국 친구들은 일본식 커리와 두부 튀김, 생선 타코 등을 요리해줬습니다. 함께 나눠먹은 음식 모두 맛있었고 미국 현지 친구의 집에서 가지는 첫 파티라 굉장히 즐겁고 재밌었습니다. 다음번에는 저희 집에 이 친구들을 초대해 대접하기로 했습니다.여기는 집 근처에 있는 동네 피자집인데, 이름은 기억이 안나서 적지 못했습니다. 그치만… 피자는 매우 맛있었고 우선 아르바이트 학생이 정말 친절했습니다. 이와 관련된 일화가 있는데, 처음에는 고등학생인줄 모르고 이 집에서 유명한 맥주를 추천 해달라고 물었습니다. 그러자 학생이 살짝 웃더니 자신은 under 21이므로 사장님께 여쭤봐주겠다고해서 그렇게 추천 받아 고른 맥주입니다. 정말 너무 맛있었습니다. 아직도 그때의 분위기와 이 맥주가 그립습니다." }, { "title": "gcloud Command-line interface Essentials", "url": "/posts/gcloud-cli-essentials/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, google cloud platform, 인프라, 클라우드, 가상머신, 구글 클라우드 플랫폼", "date": "2022-06-10 00:00:00 +0900", "snippet": "Google Cloud Platform Essentials 포스팅에 이어서 이번 포스팅에는 gcloud CLI에서 사용되는 기본적인 Command에 관하여 자세히 다뤄보려고 합니다. gcloud를 처음 접하는 사용자가 읽으면 분명 도움 될 것입니다.Google Cloud Shell이란? Cloud Shell은 Google cloud 내 Resources에 대하여 Command-line 기반으로 사용할 수 있게 해줍니다. Cloud Shell은Debian 기반의 Virtual machine이고 5GB의 Home directory를 가지고 있습니다.Cloud Shell에는 gcloud Command-line tool 외에도 빠르고 쉬운 배포를 위한 다양한 툴들이 사전 설치되어 있습니다.gcloud를 통해 Regions과 Zones 관리 Regions과 Zones에 대한 개념은 이전 포스팅 Google Cloud Platform Essentials 포스팅에서 충분히 알아보았습니다. 따라서, 이에 대한 설명은 생략하고 어떤 명령어를 통해 이들을 관리할 수 있는지 알아보겠습니다. Region 설정하기 gcloud config set compute/region us-central1 프로젝트의 Region 조회 gcloud config get-value compute/region Zone 설정하기 gcloud config set compute/zone us-central1-b 프로젝트의 Zone 조회 gcloud config get-value compute/zone gcloud를 통해 Project 정보 조회 GCP 안에는 효율적인 관리를 위해 프로젝트 단위로 관리됩니다. 이러한 프로젝트는 각각 고유한 Project id를 가지고 있습니다. Project id 조회 gcloud config get-value project Project에 대한 세부 정보 조회 gcloud compute project-info describe --project $(gcloud config get-value project) 위 Command에서 $(명령어)은 앞으로도 자주 나올 문법이니 잘 알아두도록 합시다. $(명령어) 구문은 안에 명령어를 실행한 결과를 그 자리에 내뱉는다. 위 예시에서는 해당 명령어가 Project id를 리턴하는 것입니다. gcloud를 통해 환경 변수 설정 Environment variable을 설정해두면 API나 실행 파일들을 포함하는 스크립트를 작성할 때 시간을 절약할 수 있게 해줍니다. Project id에 관한 환경 변수 설정 export PROJECT_ID=$(gcloud config get-value project) 앞서 배웠던 $(명령어) 구문을 활용해서 PROJECT_ID라는 이름의 환경 변수에 현재 프로젝트의 id를 저장하였습니다. Zone에 관한 환경 변수 설정 export ZONE=$(gcloud config get-value compute/zone) 설정한 환경 변수 조회 echo -e \"PROJECT ID: $PROJECT_ID\\nZONE: $ZONE\" gcloud를 통해 Virtual machine 생성 이전 포스팅을 보고 온 사람이라면 아래 명령어가 낯 익어보일 수 있습니다. gcloud compute instances create [만들 인스턴스 이름] --machine-type n1-standard-2 --zone $ZONE 그렇습니다. 위 명령어는 이전 포스팅에 있던 명령어와 매우 비슷하며, –zone의 Parameter로 위에서 설정한 환경 변수를 넣어준 것 뿐입니다.위처럼, 환경 변수를 사용하면 스크립트를 조금 더 빠르고 편하게 작성할 수 있습니다.gcloud 명령어 더 둘러보기 gcloud tool은 -h(help) flag를 제공해줍니다. 따라서, 어떠한 gcloud command에도 맨 뒤에 -h를 붙이면 관련 설명을 볼 수 있습니다. help flag 사용 예시 gcloud -h gcloud config --help gcloud help config 사용자 환경의 구성 목록 조회 gcloud config list gcloud config list --all 더 자세히 보려면 –all 플래그를 붙이면 됩니다. 컴포넌트 목록 조회 gcloud components list filtering을 활용한 gcloud 명령어 사용 gcloud는 다양한 기능을 갖추고 있는데, 그 중 하나가 filtering 기능입니다. 사용자가 원하는 대로 가공하여 정보를 볼 수 있습니다. Project 내 instances 목록 조회 gcloud compute instances list 위 명령어를 통해 우리는 프로젝트 내 존재하는 모든 인스턴스들의 목록을 아래와 같이 볼 수 있습니다. NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUScloudlearningservices us-central1-a e2-standard-2 10.128.0.2 35.202.228.143 RUNNINGgcelab2 us-central1-b n1-standard-2 10.128.0.2 34.68.7.186 RUNNING NAME에 대한 filtering 적용 gcloud compute instances list --filter=\"name=('gcelab2')\" NAME 컬럼이 gcelab2인 결과만 보여주도록 설정한 것입니다. 따라서 위 명령어의 결과는 아래와 같습니다. NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSgcelab2 us-central1-b n1-standard-2 10.128.0.2 34.68.7.186 RUNNING Firewall rules 조회 명령어에 filtering 적용 예시 gcloud compute firewall-rules list gcloud compute firewall-rules list --filter=\"network='default'\" gcloud compute firewall-rules list --filter=\"NETWORK:'default' AND ALLOW:'icmp'\" 위처럼 AND 연산자를 사용하여 이중 필터를 걸어줄 수도 있습니다. 참고로 여기서 NETWORK, ALLOW는 firewall-rules list의 컬럼입니다. Firewall Rules 설정 우리가 만든 instances는 클라우드 상에 올라가기 때문에 방화벽과 같은 보안 규칙이 잘 되어있지 않으면 해킹의 우려가 있습니다.따라서 우리는 방화벽에 대한 이해와 활용이 매우 중요합니다. 지금부터는 기본적인 방화벽 규칙 설정법에 대하여 배워보겠습니다. Firewall rules 조회 gcloud compute firewall-rules list 앞선 예시에서 자주 나왔던 gcelab2라는 이름의 Virtual machine에 Webserver인 nginx가 설치되어 있다고 가정해봅시다.nginx는 tcp:80포트를 통해 접근할 수 있는데, gcelabe2 Virtual machine의 external IP:80 포트로 접근해보면연결이 안된다는 것을 확인할 수 있습니다.그 이유는, 우리가 gcelab2에 대한 적절한 방화벽 규칙을 설정해주지 않아서인데, gcelab2가 tcp:80포트에 대한 연결을허용할 수 있도록 방화벽 규칙을 설정해보겠습니다. 우선 큰 순서는 다음과 같습니다. gcelab2에 태그를 붙입니다. (후에 방화벽 규칙의 Target을 tag로 지정하기 때문) gcloud compute instances add-tags gcelab2 --tags http-server, https-server tcp:80포트를 허용하는 방화벽 규칙을 만듭니다. (이때, 해당 방화벽 규칙의 target은 gcelab2의 태그로 설정) gcloud compute firewall-rules create default-allow-http --direction=INGRESS --priority=1000 --network=default --action=ALLOW --rules=tcp:80 --source-ranges=0.0.0.0/0 --target-tags=http-server 위에서 만든 방화벽이 잘 생성되어 있는지 아래 명령어를 통해 확인해봅시다.gcloud compute firewall-rules list --filter=ALLOW:'80'방화벽 설정이 모두 끝났으니, 이제 최종적으로 gcelab2 인스턴스에 nginx server에 연결이 잘 되는지 아래 명령어를 통해 확인해봅시다.curl http://$(gcloud compute instances list --filter=name:gcelab2 --format='value(EXTERNAL_IP)')References https://cloud.google.com/https://www.cloudskillsboost.google/focuses/563?parent=catalog" }, { "title": "Google Cloud Platform Essentials", "url": "/posts/google-cloud-essentials/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, google cloud platform, 인프라, 클라우드, 가상머신, 구글 클라우드 플랫폼", "date": "2022-06-09 00:00:00 +0900", "snippet": "이전 포스팅들을 통해 알 수 있듯이, 현재 미국 Purdue 대학교에서 Kubernetes와 LoRa Network를 활용한 연구를 진행중입니다.연구 실험을 위한 서비스들은 모두 클라우드 기반으로 구현하기로 했습니다. 크고 다양한 클라우드 제공 업체들이 있지만, 그중에서도 우리는 GCP(Google Cloud Platform)을 사용하기로 했습니다.왜 GCP를 선택하였는가? 사실 처음엔 클라우드 서비스 업체 점유율 1위인 AWS를 아무 생각 없이 사용하려고 했습니다. 하지만, AWS 같은 경우엔 복합적인 이유로학교 측에서 비용 지원이 어렵다고 하여 차선택인 GCP를 사용하게 되었습니다. 근데, 막상 선택하고보니 잘 선택했다는 생각이 듭니다.우선 우리의 연구 핵심인 Kubernetes는 처음에 Google 팀에서 개발한 것입니다. 그렇다보니 GKE(Google Kubernetes Engine)와 같은 쿠버네티스 관련 서비스도 뭔가 더 강력할 것 같고, 사실 그보다도 AWS의 Kubernetes 서비스인 EKS(Elastic Kubernetes Service)보다GCP의 GKE가 더 직관적이고 관리하기 쉽게 UI/UX가 구성되어 있다는 점이 굉장히 큰 매력으로 다가왔습니다.다 각설하고, 그래서 이제부터 GCP를 사용하기 위한 기본적인 개념과 구조들을 정리하고자 합니다.GCP(Google Cloud Platform)이란? Google Cloud Platform은 이름으로부터 쉽게 유추할 수 있듯이, Google 인프라 기반으로 호스팅되는 다양한 클라우드 서비스들의 모음입니다.컴퓨팅, 스토리지, 데이터 분석, 머신러닝, 네트워킹 등 Google Cloud는 개인용부터 엔터프라이즈 급에 이르는 모든 클라우드 컴퓨팅 애플리케이션 또는 프로젝트에 통합할 수 있는 다양한 서비스 및 API를 제공합니다. 그 중에서도 우리는, GCP를 사용한다면 가장 먼저 접할 가능성이 높은 가상 머신 서비스(Compute Engine)에 대해 알아보고자 합니다.Compute Engine이란? GCP 내 Compute Engine이라는 서비스가 있습니다. 이를 통해 우리는 Google 인프라 위에 다양한 OS를 실행시킬 수 있는 가상 머신과 데이터를 저장할 스토리지 등을 만들 수 있습니다. 우리는 이러한 Resources를 필요한만큼 Hardware의 성능과 개수를 선택하여 구매할 수 있습니다. 이에 따라 발생하는 비용은 사용한만큼 매달 청구됩니다. 이렇게 만들어진 Compute Engine resources는 Region 또는 Zone에 위치하게 됩니다. 우리는 이러한 Region과 Zone에 대한 개념에 대해 명확히 구분지을 필요가 있습니다.Regions과 Zones이란? 앞서 알아본 것처럼 Compute Engine resources는 Region 또는 Zone에 위치하게 되는데, Region은 resources를 실행할 수 있는특정 지리적 위치입니다. 그리고 이러한 Region은 1개 이상의 Zone을 포함합니다.예를 들어, us-central1이라는 Region은 Central United states를 담당하며 이러한 Region은 us-central1-a, us-central1-b,us-central1-c, and us-central1-f 와 같은 총 4개의 Zone을 가지고 있습니다.Zone에 위치하는 resources를 Zonal resources라고 하며, Virtual machine instances와 Persistent disks들이 Zone에 위치합니다.만약 Persistent disks를 Virtual machine instances에 붙이고 싶다면 두 resources는 무조건 같은 Zone에 위치해야 합니다.이와 유사하게, instance에 static IP를 부여하고 싶다면 instance와 static IP는 같은 Region에 있어야 합니다.Virtual machine instances 생성 방법? GCP를 통해 Virtual machine instances를 생성하는 방법에는 크게 2가지가 있습니다.첫번째는 GCP 웹 브라우저 콘솔을 이용해 GUI기반으로 생성하는 방법이고, 두번째는 GCP의 Cloud shell을 통해 명령어로 생성하는 방법이 있습니다.GUI를 기반으로 생성하는 것은 크게 배경 지식이 없어도 가능하므로 생략하도록 하고 여기선 Cloud shell을 통한 instance 생성에 대하여 다룹니다.gcloud compute instances create [만들 인스턴스 이름] --machine-type n1-standard-2 --zone us-central1-f 위 명령어처럼 Cloud shell에 입력해주면 바로 instance 생성이 가능합니다. 이렇게 만들어진 instance에 SSH 연결도 가능한데,gcloud compute ssh [연결할 인스턴스 이름] --zone us-central1-f이렇게 입력해주면 위에서 만들었던 인스턴스에 바로 SSH 연결이 가능합니다.다음 포스팅에서는 오늘 Cloud shell에서 사용한 gcloud command line tool에 대해 조금 더 깊이있게 다뤄볼 예정입니다.References https://cloud.google.com/https://www.cloudskillsboost.google/focuses/3563?parent=catalog" }, { "title": "Kubernetes의 Docker 지원 중단", "url": "/posts/kubernetes-docker/", "categories": "Computer engineering, Cloud infrastructure", "tags": "cloud infrastructure, kubernetes, docker, 인프라, 클라우드, 쿠버네티스, 도커", "date": "2022-06-07 00:00:00 +0900", "snippet": "퍼듀대학교 K-SW Sqaure 프로그램에서, 쿠버네티스에 관한 주제를 가지고 분산 처리 컴퓨팅에 대한 연구를 진행하고 있습니다.이번 포스팅에서는 Kubernetes의 Docker 지원 중단 이슈에 대하여 살펴보고 어떻게 대처할 수 있는지 자세히 알아보려고 합니다.Kubernetes의 Docker 지원 중단 ? Kubernetes에 관심이 있는 사람이라면, Docker 지원 중단에 대한 이야기를 한번쯤 들어봤을 것입니다. 처음에 Docker 지원 중단에 대한 이야기를 들으면, 굉장히 당황할 수 있습니다. 하지만, 그 속사정을 들어보면 그들이왜 그러한 결정을 했는지 이해할 수 있습니다.Kubernetes는 다양한 기능들을 바탕으로 컨테이너들을 편하게 관리하는 오케스트레이션 툴입니다. 컨테이너와 떼려야 뗄 수 없는 관계인 것입니다. 그러한 컨테이너들을 빌드하고 관리하는 패키지인, 도커에 대한 지원을 중단한다는 것이얼마나 당혹스러웠는지 본인도 잘 알고 있습니다. 쿠버네티스는 컨테이너들의 이미지를 바탕으로 관리하는데, 도커 이미지는 OCI(Open Container Initiative)라는 표준을 따릅니다. 이 표준에 부합한다면, 컨테이너를 도커로 빌드했던 안했건 도구에 관계없이 쿠버네티스 상에서는 똑같이 받아들입니다. 그리고 쿠버네티스에서는 컨테이너 이미지를 가져오고 실행하는 역할을 하는 컨테이너 런타임이 필수적으로 필요한데, 이를 위해 지금까지는 도커의 컨테이너 런타임,즉 Containerd를 사용하고 있었습니다. 하지만, Docker는 CRI(Container Runtime Interface)라는 표준을 준수하지 않습니다. 이러한 표준을 맞춰주기 위해 쿠버네티스는 Dockershim이라는 또 다른 도구를 활용하여 사용해왔습니다. 이러한 과정에서의 의존성, 유지 보수성, 오버 헤드 등의 문제가 지속적으로 발생해왔습니다. 그래서 Kubernetes 팀에서는 이러한 문제를 해결하고자 Container runtime으로 Docker를 거친 Containerd를사용하는 것이 아닌, Containerd와 같은 컨테이너 런타임 그 자체를 직접 사용하고자 한 것입니다.Docker 기반에서 Containerd로 마이그레이션 최근 쿠버네티스 릴리즈에서 실제로 도커에 대한 지원이 중단되면서 도커에서 제공하는 Containerd 런타임을 사용할 수 없게 되었습니다.따라서 우리는 CRI 표준을 준수하는 Containerd, CRI-O 등과 같은 컨테이너 런타임을 직접 설치하고 쿠버네티스가이를 인지할 수 있게 설정을 변경해주어야 합니다.컨테이너 런타임 설치는 다양한 경로와 방법이 공식 사이트에 잘 나와있으므로 생략하고, 여러 컨테이너 런타임 중에서 가장 흔히 쓰이는Containerd 설치가 완료된 상태에서 어떻게 쿠버네티스 설정을 변경할 수 있는지에 대해 적어보려고 합니다./etc/containerd/config.toml 경로에 있는 config.toml 파일에 들어가봅니다....disabled_plugins = [\"cri\"]...Containerd를 RPM이나 .deb와 같은 패키지로부터 설치하게 되면, 디폴트 값으로 위와 같이 CRI integration plugin을 사용할 수 없게설정 되어있습니다. 위 문장을 주석처리하여 쿠버네티스가 Containerd를 사용할 수 있게 변경해줄 수 있습니다. 파일 수정을 모두 마쳤다면, sudo systemctl restart containerd 위 코드를 통해 업데이트 시켜주면 Kubernetes의 컨테이너 런타임 변경이 모두 완료됩니다.References https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/https://kubernetes.io/blog/2022/02/17/dockershim-faq/https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd" }, { "title": "Purdue University 5th", "url": "/posts/purdue-5th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-06-03 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.지금까지의 포스팅에서는 너무 먹는 사진 위주로 올린 거 같아서, 이번주 포스팅은 퍼듀에서의 활동으로 시작하려고 합니다.어린이 카트를 타고 신난 Logan!마침 매년 4월의 대행사인 퍼듀 그랑프리가 열려 냅다 달려갔습니다.레이싱 대회는 처음 가보는데, 심장 뛰게 만드는 엔진소리와 냄새가 매우 박진감 넘치게 만들어줍니다.엄청나게 많은 카트가 동시에 달리다보니 이런 충돌 사고가 비일비재 했습니다. 경기중 큰 부상자는 없어서 다행이었습니다.이건 그랑프리에서 사먹은 핫도그와 감자인데, 들어간 재료는 생각보다 별건 없지만 매우 맛있었습니다.그랑프리 갔다와서 라면과 군만두를 해먹었습니다. 참고로 저 군만두는 한국식 비비고 군만두이고 라면도 신라면입니다~ 매우 맛있었습니다.저녁도 든든하게 먹었겠다, K-SW 친구들 여럿이랑 함께 농구를 했습니다. 중학생 때부터 농구를 좋아했지만 오랜만에 했더니 너무 힘들었습니다. 그치만 재밌었습니다.운동 마치고 친구들이랑 다같이 홈파티를 가졌습니다.그나저나 불과 몇일 전 사진인 거 같은데 지금 얼굴이 더 부어보이는 것은 기분 탓인지 모르겠습니다..이번주 포스팅의 마무리는 귀여운 Gram과 함께하려고 합니다.Gram은 Prof.Smith의 강아지입니다. 아주 부끄러움이 많고 귀여운 녀석입니다. 앞으로도 종종 포스팅에 등장할 예정입니다.진짜로 마무리 짓기 전, 음식 사진 투척~ 그나저나 휘핑 크림 인심 너무 후합니다." }, { "title": "Purdue University 4th", "url": "/posts/purdue-4th/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-05-27 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.K-SW Square 빌딩 앞에서 다같이 한 컷오늘은 다함께 캠퍼스 투어가 있는 날입니다. 때마침 날씨가 너무 좋았습니다.여기는 K-SW Square 빌딩 바로 옆 건물인, Purdue churchPurdue logo를 시작으로 캠퍼스를 쭉 따라 걸었습니다.퍼듀 정문도 통과해줍니다.졸업할 때 퍼듀 학생들이 반드시 한번은 통과한다는 분수까지다음은, 퍼듀 스포츠 센터인 corec입니다. 안에 직원 분께서 전체적인 건물을 함께 돌며 가이드까지 해주셨는데, 운동 종목이나 기구들도 엄청 많고 시설이 어마어마하게 좋았습니다.캠퍼스 투어를 하던 중, 뷰가 너무 이뻐서 서로 프로필 사진을 찍어줬습니다. 사진에 진심인 우리들…!그렇게 건진 제 프로필 사진. 짠! 이렇게 이번주 포스팅을 마칩니다." }, { "title": "Purdue University 3rd", "url": "/posts/purdue-3rd/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-05-19 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.퍼듀대학교 캠퍼스 뷰로 시작하는 3번째 포스팅저희 학교도 캠퍼스 크기로 어디가서 주눅들진 않는데, 미국은 워낙 땅이 넓어서 그런지 캠퍼스도 넓고 안에 없는 것이 없습니다.예를 들어) 퍼듀 공항, 풋볼 스타디움, 야구장, Grand Prix 레이싱장 등등 …원래 아침 먹을겸 주로 스타벅스에 가서 샌드위치와 커피로 하루를 시작하는데 오늘은 PMU (Purdue Memorial Union)안에 있는 마켓에서 샌드위치를 사먹었습니다.근데 엄청 맛없는 김치전 맛이었습니다. 사먹고 진짜 후회했습니다. 그 뒤로 다신 사먹지 않습니다…이건 그 후 먹은 Panda Express 라는 American chinese food 음식점입니다. 개인적으로 퍼듀 생활하면서 엄청 자주갔고, 그만큼 맛도 좋습니다.다양한 반찬들을 Bowl에 골라 담아 함께 먹습니다. 개인적으로, 쉬림프랑 데리야끼 치킨을 가장 좋아합니다.포스팅이 어찌 다 먹는 얘기 뿐인 거 같긴한데, 착각이었으면 좋겠다.다음으로 저녁은 Kimchi라는 한식 레스토랑입니다. 처음으로 미국에서 먹어본 한식이라 기대가 매우 컸는데, 모든 음식과 반찬이 다 짰습니다.심지어 밑반찬으로 나온 삶은 브로콜리조차도 소금물을 먹는 줄 알았습니다.그건 그렇고, 사실 한식 레스토랑에 다같이 가게 된 계기는 저희가 이렇게 미국 생활에 잘 적응하고 도착할 수 있게 도와주신 IITP측의 책임님의 송별회를 갖기 위해서였습니다. 책임님은 정말 주야, 평일 주말 가리지 않고 언제나 일이 있으면 상냥하게 맞아주십니다. 책임님을 싫어하는 사람은 이 세상에 있을 수 없을 거 같습니다.그러한 책임님을 한국으로 보내드리기 전, 마지막 식사였던 것입니다. 굉장히 아쉬움이 많이 남았습니다.특히나 저를 비롯한 일부 최고령자 친구들은 책임님과 더욱 돈독한 사이가 될 수 밖에 없었는데, 그래서 더욱 아쉽고 지금도 종종 연락을 주고 받습니다.그렇게 송별회를 가진 뒤, K-SW 친구들과 함께 맞이하는 첫번째 생일자 파티나중에 이 주인공은 같은 팀의 팀원이 됩니다. 가영아 다시 한번 생일 축하해.이렇게 이번주 포스팅도 마무리" }, { "title": "Purdue University 2nd", "url": "/posts/purdue-2nd/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-05-11 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW Sqaure 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.Purdue K-SW Square로 처음 출근하는 길여기 분명 4월인데… 밖에 눈이 내렸습니다.물론 그 뒤로 눈을 다시 보진 못했습니다.오늘 점심 메뉴는 제가 좋아하는 케인즈치킨 핑거랑 감자튀김이 주 메인인데 진짜 맛있었습니다. 감자튀김은 제법 짭짤하지만, 치킨 핑거는 간이 적당하니 맛있습니다.K-SW Sqaure 친구들이랑 같이 장보러 walmart에 갔습니다. 퍼듀에 온지 얼마 안됐는데, 다들 성격이 좋아서 금새 모두 친해졌습니다.미국 생활 얼마 안됐지만 벌써 한식이 그리워 끓인 김치찌개매우 맛있었습니다.멋진 하늘과 함께 2주차 포스팅도 마무리" }, { "title": "Purdue University 1st", "url": "/posts/purdue-1st/", "categories": "Daily, Purdue", "tags": "purdue, k-sw square, k-sw 스퀘어, 퍼듀대학교, IITP, SW중심대학사업단, 글로벌 교육", "date": "2022-05-05 00:00:00 +0900", "snippet": "정보통신기획평가원(IITP)와 Purdue University의 지원을 받아 참여한 4개월 간의 K-SW 스퀘어 프로그램.이 포스팅이 추후 본 프로그램에 지원하는 학생들에게 도움이 되길 바랍니다. 관련 질문이 있으시면 메일이나 코멘트 부탁드립니다.K-SW 스퀘어 프로그램에 참가하기 위해 4월 17일 미국으로 출국하게 되었습니다.퍼듀 대학교가 있는 인디애나 주로 가기까지 대략 18시간 넘게 걸린 것 같습니다. 매우 피곤했답니다.원래는 3월 초부터 미국에 있었어야 하는 게 맞지만, 코로나 팬데믹으로 비자 인터뷰가 지연되면서 덩달아 출발 일정이 밀렸습니다.지금부터 저의 첫 깃블로그를 퍼듀대에서의 생활로 담아보려고 합니다.1. 인천 -&gt; 애틀랜타 -&gt; 인디애나인천에서 애틀랜타를 경유하여 인디애나로 출발엄청난 장거리 비행을 마치고 애틀랜타 도착 직전오면서 먹은 기내식입니다. 첫 번째는 제육 쌈밥을 먹었고 두 번째로는 김치볶음밥을 먹었습니다. 모두 너무 맛있었습니다.현재, 이 글을 쓰는 시점이 미국 생활 3주차인데 한국 음식이 많이 그립습니다. 너무 기름집니다.이건 간식으로 나온 불고기와 스낵인데, 사실 이거 외에도 와인 및 주스같은 음료들과 간식들을 엄청 많이 받았습니다.비행기에서 제 옆자리에 앉게된 K-SW 친구와 함께 승무원 분이랑 엄청 친해져서 대화도 많이 나누고, 먹을 것도 많이 받아서 행복했습니다. 맛있는 거 주는 사람은 착한 사람입니다.2. 퍼듀대에서의 첫 아침미국 도착하자마자 짐 풀고 바로 깊은 숙면.. 월요일인 다음날 아침 일찍 일어나, K-SW Square로 향했습니다.여기는 제가 사는 아파트입니다. 한국 외대 친구들 2명과 함께 나포함 총 3명이 삽니다. 앞으로 제 블로그에 자주 등장할 예정이니까 미리 소개하겠습니다.우선, 블로그 주인인 “저”. 미국에선 Logan으로 불립니다.다음은, 제 룸메이트 중 막내 귀요미 Ethan입니다.마지막으로, 저와 동갑내기 친구 Koo입니다.이들과 하루 종일 붙어 있을 정도로 벌써 매우 친합니다! 지금부터 본격적으로 K-SW Square에서 펼쳐질 흥미롭고 유익한 여정을 시작합니다.끝으로, 이건 미국에서 처음 먹은 아침 식사. 매일 아침 일찍 일어나 저와 제 룸메이트들은 스타벅스에 갑니다. 커피가 없으면 오전이 너무 괴롭습니다.K-SW Sqaure로 출발" }, { "title": "카카오_ 문자열 - Level2 - 오픈채팅방", "url": "/posts/open-chat-room/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, string, 카카오, 오픈채팅방, 문자열, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-10-22 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 카카오 - 오픈채팅방 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;vector&lt;string&gt; solution(vector&lt;string&gt; record) { vector&lt;string&gt; answer; map&lt;string, string&gt; m; //map의 first가 uid, second가 nickname string uid = \"\"; string name = \"\"; string result = \"\"; char* str_buff = new char[1000]; for(int i=0; i &lt; record.size(); i++) { strcpy(str_buff, record[i].c_str()); char* tok = strtok(str_buff, \" \"); if(string(tok) == \"Change\" || string(tok) == \"Enter\") { tok = strtok(nullptr, \" \"); uid = string(tok); tok = strtok(nullptr, \" \"); name = string(tok); m[uid] = name; } } for(int i=0; i &lt; record.size(); i++) { result = \"\"; strcpy(str_buff, record[i].c_str()); char* tok = strtok(str_buff, \" \"); if(string(tok) == \"Enter\") { tok = strtok(nullptr, \" \"); result += m[string(tok)]; result += \"님이 들어왔습니다.\"; answer.push_back(result); } else if(string(tok) == \"Leave\") { tok = strtok(nullptr, \" \"); result += m[string(tok)]; result += \"님이 나갔습니다.\"; answer.push_back(result); } } return answer;}우선 이 문제를 이해하고 일반화된 식 혹은 알고리즘을 찾는 것은 그렇게 어렵지 않을 겁니다. 오픈채팅방에 사용자들이 들어오거나 나가면서 닉네임을 바꿀 수 있게 되는데 가장 나중에 변경된 닉네임으로 최종적인 접속 로그가 찍히는 방식입니다. 즉 마지막에 각 userId별로 최종적으로 어떤 닉네임을 가지게 되는지가 관건입니다. 그 후에는 그대로 출력만 해주면되서 어렵지는 않습니다.저는 일단 각 userId와 nickname을 엮어주고 빠른 시간으로 효율적으로 탐색하기 위해 map이라는 자료 구조를 사용했습니다. 이전 포스팅에서도 유용하게 사용했던 알고리즘인데 오랜만에 보니까 간단히 정리하겠습니다.map이란? map은 Key와 Value 쌍으로 이루어진 자료 구조이며 key값을 주면 value 값을 반환하게 됩니다. map은 &lt;map&gt;이라는 헤더파일 내에 존재합니다. 또한 map은 중복을 허용하지 않으며 c++ map의 내부는 검색, 삽입, 삭제가 O(logN)인 레드블랙트리로 구현되어 있습니다. 매우 빠릅니다.map의 선언은 아래와 같습니다. map&lt;key, value&gt; map1; map에서 &lt;key, value&gt; 쌍을 삽입하는 것은 아래와 같이 합니다. map1[key] = value;혹은map1.insert(make_pair(key, value)); 이제 그 다음 알고리즘 내 핵심은 공백을 기준으로한 문자열 토큰화입니다. 공백을 기준으로 문자열을 잘라야 하는데 CPP기준 이 부분에 있어서는 크게 2가지의 방법이 존재하는 것 같습니다. 저는 그 중에서 cstring 헤더파일 내의 strtok()를 이용하였습니다.strtok()란? char* strtok(char* str, char* delimiters); 이런 식으로 구성된 토크나이징 함수입니다. cpp에서는 **이라는 헤더파일 내에 존재**하고 있습니다. **delimiters라고 하면 구분 문자를 뜻하는데 구분 문자를 기준으로 string을 쪼갠다고 생각**하면 됩니다. 우선 위 함수 원형에서 볼 수 있듯이 **매개변수로 char*를 받기 때문에 cpp에서 흔히 쓰는 string을 그대로 넘겨주는 것은 불가능**합니다. 그래서 s**tring을 C style처럼 char* 형으로 바꿔주는 작업이 필요한데 여기서 또 하나 중요한 것이 매겨변수로 넘겨주는 str에 실체가 있는 문자 배열이어야 한다는 점**. 즉, **문자열 리터럴(문자열 상수: 실체가 없음)은 안된다**는 것 입니다. 쉽게 이해하기 위해 첨언하자면 **strtok() 메소드 내부에서 토크나이징을 위해 delimeters가 위치한 부분의 문자를 '\\0'으로 바꾸는 과정이 있는데 문자열 리터럴은 기본적으로 const가 걸려있기 때문에 이러한 변경이 안됩니다. 그래서 에러가 발생**합니다.그래서 저는 아래와 같은 작업을 해줬습니다. //strtok 매개변수로는 실체가 있는 문자 배열만이 가능하므로 문자 배열 선언char* str_buff = new char[1000]; //우선 string 클래스를 c_str()를 통해 string을 char* 형으로 바꿔줍니다.strcpy(str_buff, record[i].c_str()); 근데 여기서 중요한 점이 있습니다.record[i].c_str()이 이미 char인데 이걸 그대로 strtok()의 str 매개변수로 바로 쓰면 되는데 왜 이렇게 strcpy()를 통해서 다른 문자 배열로 옮겨준 것 일까요?** **그 이유는 바로 c_str() 메소드는 char 형을 리턴하는 것이 아니고 const char* 형을 리턴하기 때문입니다. 이렇게 되면 앞서 말한 것처럼 strtok()이 해당 문자열에 구분 문자를 ‘\\0’으로 변경시키는 작업을 하지 못하기 때문에 const가 없는 또다른 문자 배열에 strcpy()를 했다고 이해하시면 됩니다.그 후 아래처럼 이제 본격적으로 strtok()를 사용해주면 되는데, char* tok = strtok(str_buff, \" \"); strtok()의 반환형이 char* 임에 주의해주시고, 또 하나 중요한 점이 1번 strtok()를 하고 나서 그 다음 토큰을 찾을 때는 아래와 같이 null 혹은 nullptr을 준다는 것을 기억합시다. tok = strtok(nullptr, \" \"); 이렇게 널 포인터를 주는 이유는 strtok 내부 동작 원리 자체가 null 값을 넘겨주면 이전에 찾은 구분자 뒤에서부터 찾도록 구현이 되어있기 때문입니다. 만약에 토크나이징 하다가 더이상 자를 게 없는 문자열 끝에 도달하게 되면 strtok()는 null 값을 리턴하게 된다는 것도 알아두시면 좋을 것 같습니다.참고로 이 문제에서는 굳이 그것까지 고려해줄 필요가 없어서 따로 쓰지는 않았습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;vector&lt;string&gt; solution(vector&lt;string&gt; record) { vector&lt;string&gt; answer; string command; string ID; string uid; map&lt;string,string&gt; m; for(string input:record) { stringstream ss(input); ss&gt;&gt;command; ss&gt;&gt;uid; if(command==\"Enter\" || command==\"Change\") { ss&gt;&gt;ID; m[uid]=ID; } } for(string input:record) { stringstream ss(input); ss&gt;&gt;command; ss&gt;&gt;uid; if(command==\"Enter\") { ID=(m.find(uid)-&gt;second); string temp = ID+\"님이 들어왔습니다.\"; answer.push_back(temp); } else if(command==\"Leave\") { ID=(m.find(uid)-&gt;second); string temp = ID+\"님이 나갔습니다.\"; answer.push_back(temp); } } return answer;}위 알고리즘이 무려 추천 수를 17개나 받은 알고리즘인데 큰 흐름 자체는 저와 똑같습니다. 하나 다른점이라고 한다면 토크나이징 방식이 다릅니다. 제가 이번 포스팅 초반에 말했던 것처럼 cpp 내 토크나이징 방법은 크게 2가지가 있다고 했는데 그 중에 하나는 제가 사용한 &lt;cstring&gt; 내부에 strtok()이고 나머지 하나가 바로 위 풀이에서 사용된 것처럼 stringstream을 활용하는 것입니다.stringstream이란? stringstream은 주어진 문자열에서 필요한 정보를 빼낼 때 유용하게 사용됩니다. 특히나 내가 전달해주는 자료형과 일치하는 부분만 공백, ‘\\n’을 무시하고 추출합니다. stringstream은 &lt;sstream&gt;이라는 헤더 파일 내에 구현되어 있습니다. stringstream ss(input); 우선 stringstream을 사용하기 위해서 위처럼 객체를 선언해줍니다. 생성자를 이용해서 input이라는 string 값을 가지는 stringstream 객체를 생성한 것인데 위에처럼 선언 시에 해도 되고 아니면 아래와 같이 추후에 stringstream에 들어가있는 string 값을 바꿔주거나 새로 넣어줄 수도 있습니다. ss.str(input); 근데 여기서 하나 주의할 것이 같은 stringstream 객체를 어느정도 쓰다가 ss.str(input);과 같이 새로운 string 값을 넣어준 뒤 바로 사용하려고 하면 이전 string 값으로 사용하다가 남은 Flag들이 그대로 저장되어 있어서 올바르게 동작하지 않을 수도 있으니 동일한 stringstream 객체에 string 값만 바꿔가면서 계속 사용한다고 한다면 새로운 string 값을 사용하기 전에 반드시 아래와 같이 클리어를 한번 해주고 사용해줍시다. ss.clear(); 그렇다면 이제 stringstream을 가지고** 어떻게 공백,’\\n’을 기준으로 문자열을 토크나이징 할 것인가**에 대해 알아볼까요?되게 간단합니다. 토큰을 담을 변수를 가지고 아래와 같이 사용해주면 됩니다. ss &gt;&gt; name; 위처럼 사용하면 1개의 토큰만 추출되는 것이고 이걸 문자열 끝까지 반복하려면 아래와 같이 하면 됩니다. while(ss &gt;&gt; name) {\tcout &lt;&lt; name &lt;&lt; endl;} 만약에 name이 string이면 string 타입에 맞는, 즉 문자열 내에서도 문자와 관련된 값들이 나타나는 곳까지만 추출된다는 것을 꼭 기억합시다.즉, 만약에 주어진 string이 “13 256 .25 a”이고 int형 데이터 타입을 가지는 num으로 추출을 한다면 위 반복문은 13과 256만 추출하고 끝나는 것 입니다. float num이라면 13, 256, 0.25로 추출이 됩니다.string이라면 “13”, “256”, “.25”, “a”로 추출이 됩니다.최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.References https://kamang-it.tistory.com/entry/cstring%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9D%B4%EC%95%BC%EA%B8%B0-2-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EC%9E%90%EB%A5%B4%EA%B8%B0-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%86%A0%ED%81%AC%EB%82%98%EC%9D%B4%EC%A7%95https://kimcoder.tistory.com/122https://blockdmask.tistory.com/382https://codingdog.tistory.com/entry/c-string-cstr-%ED%95%A8%EC%88%98-string%EC%9D%84-char-%EB%A1%9C-%EB%B0%94%EA%BF%94%EB%B4%85%EC%8B%9C%EB%8B%A4https://word.tistory.com/24" }, { "title": "연습 문제_ 문자열 - Level2 - 최댓값과 최솟값", "url": "/posts/max-and-min/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, string, 연습 문제, 최댓값과 최솟값, 문자열, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-10-22 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 연습문제 - 최댓값과 최솟값 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;using namespace std;string solution(string s) { string answer = \"\"; int num = 0, min = 0, max = 0; stringstream ss(s); ss &gt;&gt; num; min = max = num; while(ss &gt;&gt; num) { if(num&lt;min) min = num; if(num&gt;max) max = num; } answer = to_string(min) + \" \" + to_string(max); return answer;}바로 전날에 문자열 토크나이징과 관련된 카카오 Level2 문제를 풀었어서 그런지 이 문제는 정말 금방 풀렸습니다. 제가 앞선 포스팅에서 말씀드린 것처럼 cpp에서 문자열을 토크나이징 하는 방법에는 크게 2가지 있습니다. 저는 그중에서도 조금 더 간단한 stringstream을 이용해봤습니다.stringstream이란? stringstream은 주어진 문자열에서 필요한 정보를 빼낼 때 유용하게 사용됩니다. 특히나 내가 전달해주는 자료형과 일치하는 부분만 공백, ‘\\n’을 무시하고 추출합니다. stringstream은 &lt;sstream&gt;이라는 헤더 파일 내에 구현되어 있습니다. stringstream ss(input); 우선 stringstream을 사용하기 위해서 위처럼 객체를 선언해줘야 합니다. 생성자를 이용해서 input이라는 string 값을 가지는 stringstream 객체를 생성한 것인데 위에처럼 선언 시에 해도 되고 아니면 아래와 같이 추후에 stringstream에 들어가있는 string 값을 바꿔주거나 새로 넣어줄 수도 있습니다. ss.str(input); 근데 여기서 주의할 것이 같은 stringstream 객체를 어느정도 쓰다가 ss.str(input);과 같이 새로운 string 값을 넣어준 뒤 바로 사용하려고 하면 이전 string 값으로 사용하다가 남은 Flag들이 그대로 저장되어 있어서 올바르게 동작하지 않을 수도 있으니 동일한 stringstream 객체에 string 값만 바꿔가면서 계속 사용한다고 한다면 새로운 string 값을 사용하기 전에 반드시 아래와 같이 클리어를 한번 해주고 사용합시다. ss.clear(); 그렇다면 이제 stringstream을 가지고** 어떻게 공백,’\\n’을 기준으로 문자열을 토크나이징 할 것인가**에 대해 알아볼까요?토큰을 담을 변수를 가지고 아래와 같이 사용해주면 됩니다. ss &gt;&gt; name; 위처럼 사용하면 1개의 토큰만 추출되는 것이고 이걸 문자열 끝까지 반복하려면 아래와 같이 하면 됩니다. while(ss &gt;&gt; name) {\tcout &lt;&lt; name &lt;&lt; endl;} 만약에 name이 string이면 string 타입에 맞는, 즉 문자열 내에서도 문자와 관련된 값들이 나타나는 곳까지만 추출된다는 것을 꼭 기억합시다.즉, 만약에 주어진 string이 “13 256 .25 a”이고 int형 데이터 타입을 가지는 num으로 추출을 한다면 위 반복문은 13과 256만 추출하고 끝나는 것 입니다. float num이라면 13, 256, 0.25로 추출이 됩니다.string이라면 “13”, “256”, “.25”, “a”로 추출이 됩니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string solution(string s) { string answer = \"\"; string sTemp = \"\"; vector&lt;int&gt; vecInteger; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == ' ') { vecInteger.push_back(stoi(sTemp)); sTemp.clear(); continue; } sTemp += s[i]; } vecInteger.push_back(stoi(sTemp)); sort(vecInteger.begin(), vecInteger.end()); answer += to_string(vecInteger.front()); answer += ' '; answer += to_string(vecInteger.back()); return answer;}위 알고리즘이 추천을 많이 받은 알고리즘인데, 제 개인적인 견해입니다만 제 알고리즘처럼 stringstream을 사용하는 것이 훨씬 더 간단해보이고 좋은 것 같습니다. 그럼에도 다른 개발자의 알고리즘을 이해하고 체득한다는 건 정말 큰 의미가 있으니까 같이 한번 알아봅시다.문자열의 인덱스 접근을 하면서 공백이 나타나면 지금까지 sTemp에 쌓인 string을 Integer로 바꿔준 뒤 vecInteger라는 벡터에 차곡차곡 쌓는 방식입니다. 그 후 이걸 정렬해서 min값과 max값을 찾아내는 방식입니다. 코드 수는 조금 더 길어보이지만 위 알고리즘이 이해하기 좋네요! 역시 사람들이 추천하는 데는 이유가 있는 것 같습니다.최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다." }, { "title": "카카오_ 문자열 - Level2 - 문자열 압축", "url": "/posts/compression-of-strings/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, string, 카카오, 문자열 압축, 문자열, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-10-17 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 카카오 - 문자열 압축 풀이입니다.오늘은 카카오 블라인드 채용 문제를 준비해 봤습니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(string s) { int answer = s.length(); for(int i=1; i&lt;=s.length()/2; i++) { string temp = \"\"; int count = 1; int toggle = 0; int tempAnswer = s.length(); for(int j=0; j+i&lt;=s.length(); j += i) { if(temp != \"\" &amp;&amp; temp == s.substr(j,i)) { count++; toggle = 1; } else { if(toggle == 1) { tempAnswer = tempAnswer - (i*count-(i+1)); if(10&lt;=count &amp;&amp; count&lt;=99) tempAnswer += 1; else if(100&lt;=count &amp;&amp; count &lt;=999) tempAnswer += 2; else if(count == 1000) tempAnswer += 3; count = 1; } toggle = 0; } temp = s.substr(j,i); } if(toggle == 1) { tempAnswer = tempAnswer - (i*count-(i+1)); if(10&lt;=count &amp;&amp; count&lt;=99) tempAnswer += 1; else if(100&lt;=count &amp;&amp; count &lt;=999) tempAnswer += 2; else if(count == 1000) tempAnswer += 3; } if(tempAnswer &lt; answer) answer = tempAnswer; } return answer;}코드가 평소보다 좀 길어보입니다.그래보이긴 해도 나름대로 알아보기 쉽게 구성되어 있다고 생각합니다.일단 이 문제는 문자열 압축이라는 문제로, 문자열을 토큰화 시켜서 분리한뒤에 인접한 토큰끼리 중복된 토큰이 나타나면 Count를 1씩 증가시켜서 개수를 세주는 로직을 사용해야 합니다. 다음 다른 사람의 풀이에서도 나타나겠지만 여기에 있어서 크게 2가지로 나뉘는데, 실제로 압축된 총 문자열을 구해서 최종적으로 그 길이를 구하는 방법과 아니면 저처럼 압축된 문자열을 직접 구하지 않고 그때그때 마다 압축되면서 원래 문자열의 총 길이에서 얼만큼 줄어드는지 길이적인 관점에서만 계산을 하는 방법, 이렇게 총 2가지가 있을 것 같습니다.저는 효율성 측면이 걱정이 되서 직접 문자열을 구하진 않고 길이적인 관점에서만 계산을 했습니다. 문자열이 압축이 되면 아래와 같은 일반화된 식에서 나오는 값으로 문자열이 압축됩니다.tempAnswer = tempAnswer - (i*count-(i+1));근데 여기서 하나 주의할 점이 있습니다. 그것은 바로 위 일반화된 식은 Count 값이 1자리수 일때만 통한다는 것입니다. 그래서 저는 아래와 같이 후처리를 해줬습니다.if(10&lt;=count &amp;&amp; count&lt;=99)\ttempAnswer += 1;else if(100&lt;=count &amp;&amp; count &lt;=999)\ttempAnswer += 2;else if(count == 1000)\ttempAnswer += 3;어? 그런데 지금 이 포스팅을 적다가 보니까 위 식에서 (i+1)이 부분에서 1부분만 Count의 자리수로 일반화 시켜주면 코드가 훨씬 간결해질 수 있겠다라는 생각이 듭니다.그리고 이 코드에서 비효율적인 부분이 하나 있는데, 바로 toggle 변수를 썼다는 점입니다. 급한 마음에 toggle 변수를 추가해서 구현을 했는데 추후 최적화한 나의 풀이에서 이 부분에 대한 수정이 있으니까 꼭 끝까지 읽어보시길 바랍니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;vector&lt;string&gt; convert(string s, int n){ vector&lt;string&gt; v; for(int i = 0 ; i &lt;s.length() ; i+=n) { v.push_back(s.substr(i,n)); } return v;}int solution(string s) { int answer = 0; vector&lt;string&gt; tok; string before; int cnt = 1; int min = s.length(); string str=\"\"; for(int j = 1 ; j &lt;= s.length()/2 ; j++) { tok = convert(s,j); str = \"\"; before = tok[0]; cnt = 1; for(int i = 1 ; i &lt; tok.size() ; i++) { if(tok[i] == before) cnt++; else { if(cnt != 1) str += to_string(cnt); str += before; before = tok[i]; cnt = 1; } } if(cnt != 1)str += to_string(cnt); str += before; min = min&lt;str.length() ? min : str.length(); } cout&lt;&lt;str; return min;}위 알고리즘의 전반적인 큰 틀은 비슷하지만 앞서 말씀드린 것처럼 저와 다른 방식인, 직접 압축된 문자열을 구하는 방식입니다.일단 제 코드보다 읽기도 좋고 더 이해하기 쉽게 잘 짜여진 코드 같습니다.큰 흐름 자체는 저와 굉장히 유사하고 토큰 비교해주는 로직 내에서 직접 압축된 문자열을 str에 구하고 있다는 점만 유의해서 봐주시면 될 것 같습니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(string s) { int answer = s.length(); for(int i=1; i&lt;=s.length()/2; i++) { string temp = \"\"; int count = 1; int tempAnswer = s.length(); for(int j=0; j+i&lt;=s.length(); j += i) { if(temp != \"\" &amp;&amp; temp == s.substr(j,i)) count++; else { if(count != 1) { tempAnswer = tempAnswer - (i*count-(i+1)); if(10&lt;=count &amp;&amp; count&lt;=99) tempAnswer += 1; else if(100&lt;=count &amp;&amp; count &lt;=999) tempAnswer += 2; else if(count == 1000) tempAnswer += 3; count = 1; } } temp = s.substr(j,i); } if(count != 1) { tempAnswer = tempAnswer - (i*count-(i+1)); if(10&lt;=count &amp;&amp; count&lt;=99) tempAnswer += 1; else if(100&lt;=count &amp;&amp; count &lt;=999) tempAnswer += 2; else if(count == 1000) tempAnswer += 3; } if(tempAnswer &lt; answer) answer = tempAnswer; } return answer;}제 풀이를 다시 한번 리팩터링한 코드입니다. 뭐 크게 다를 것은 없습니다. 앞서 말씀드린 것처럼 toggle을 굳이 쓸 필요가 없어서 제거해봤습니다. 그리고 압축된 문자열의 길이를 구하는 일반화된 식에서 (i+1) 이 부분에 1은 Count의 자리수로 일반화 시키면 더 효율적인 코드가 나올 수 있을 것 같습니다." }, { "title": "연습 문제_ n진법 - Level2 - 124 나라의 숫자", "url": "/posts/number-of-124/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, base n, 연습 문제, 124 나라의 숫자, n진법, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-10-16 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 연습문제 - 124 나라의 숫자 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string solution(int n) { string answer = \"\"; vector&lt;int&gt; weight; int temp = 1; int sum = 0; for(int i=1; 1 ; i *= 3) { temp = 3 * i; if(sum + temp &lt; n) { sum += temp; continue; } else break; } while(n &gt; 0) { temp = temp/3; for(int j=1; j&lt;=3 ; j++) { if(sum+temp*j &gt;= n) { if(j==3) answer += '4'; else answer += to_string(j); sum -= temp; n -= temp*j; break; } } } return answer;}위 문제는 “124 나라의 숫자”라는 문제입니다. 사실 처음에 문제 길이도 짧고 만만해보여서 풀게 되었습니다. 저번 포스팅 이후로 고득점 kit에 있는 Level2는 모두 다 풀었기 때문입니다. 일단 이 문제를 푼 첫 소감은 불친절하다 입니다. 특히나 Test case가 너무 기본적인 것만 나와있었습니다.나름 최근에 현대모비스 코딩테스트 대회를 나가서 느꼈던 점이, ‘항상 코딩 테스트건 뭐 개발을 하건 할 때 충분한 설계와 고민을 마친 뒤에 코딩을 시작하자.’ 입니다. 정말 이번에도 크게 느꼈습니다. 그래서 더할 나위 없이 충분히 고민한 뒤에 코딩으로 들어갔습니다. 우선 제 풀이는 뒤에 나오는 다른 사람들이 푼 풀이보다 조금 더 비효율적일 순 있어도 이해하기에는 더 수월하다고 자신있게 말할 수 있을 것 같습니다.간단히 로직에 대해 설명드리면, 진법 변환을 할 때 우리가 자릿수의 weight를 고려하게 되는데 그 로직이라고 생각하시면 됩니다. 근데 이 문제에서 주의할 것이 있습니다. 무엇이냐면 예를들어서 10진수 18가 124 나라에 가면 124로 표현이 되는데, weight가 높은, 즉 높은 자릿수부터 진법 변환을 하게 되면 안된다는 것입니다. 앞서 말씀드린 18을 3^2의 weight를 가지는 위치부터 변환을 하게 되면 3^2의 무게를 가지는 자리 값은 2가 될 것입니다. 하지만 당장은 이상 없어보이지만 이제 3^1, 3^0 자리에 0이 아니면 값이 들어갈 수가 없습니다. 하지만 124 나라에는 0이 없습니다. 이런 점이 문제가 되는 것 입니다.그렇다면 어떻게 해야하나 생각하다가 저는 낮은 자리수부터 표현할 수 있는 최대 정수를 sum과 같은 변수에 차곡차곡 누적시켜놓고 가장 높은 자리수에서 계수를 과소비하는 것을 방지하도록 구현했습니다. 그 방식이 바로 저의 알고리즘입니다.마지막으로 하나 더 주의를 해야되는 부분이 있다면 124 나라에서 1,2는 1,2 그대로를 의미하지만 3진법 체계라는 점에 따라서 4는 3과 같은 의미를 지니게 됩니다. 그래서 10진수 상의 3의 값으로 치환되었다면 우리는 answer에 3이 아닌 4를 넣어줘야함을 잊으시면 안됩니다.다른 사람의 풀이1#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;string change124(int no){ string answer = \"\"; int a; while(no &gt; 0){ a = no % 3; no = no / 3; if (a == 0){ no -= 1; } answer = \"412\"[a] + answer; } return answer;}int main(){ int testNo = 6; string testAnswer = change124(testNo); cout&lt;&lt;testAnswer;}처음에 이 알고리즘 보고 이해가 안되서 구글링을 좀 해봤었는데 타 언어를 쓰시는 분들도 위처럼 효율적으로 많이 짠 것을 보았습니다.기본적으로 위 알고리즘은 n을 가지고 3진법 변환하는 식을 사용한 것입니다. 우리 보통 진법 변환할 때 모듈러 연산자 이용해서 나머지로 표현하는데 바로 그 로직입니다. 근데 딱 하나 다른 점이 있습니다. 나머지가 0이면 숫자 n에서 1을 빼주고 다음 진법 변환을 진행합니다. 왜 그럴까요?그 이유가 핵심인데, 124 나라에서는 일반적인 3진법처럼 0,1,2로 이루어져 있지 않기 때문입니다. 더 나아가서 일반적인 3진법에 0의 존재 이유는 단순 없음을 표현하는 것도 있겠지만 그 뿐만 아니라 다음 자리수의 수를 1개 늘려서 3의 배수(3으로 나누어 떨어짐)을 표현하고자 하는 것인데 124 나라에서는 자리수를 늘리지 않고 기존 자리에서 4라는 숫자로 3을 대신하고 있습니다. 이렇게 자리수가 늘어나지 않기 때문에 n에서 1을 빼주는 것으로 이해하시면 됩니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int convert[3] = {1,2,4};string solution(int n) { string str = \"\"; while(true){ n -= 1; int tmp = n % 3; str = to_string(convert[tmp]) + str; n /= 3; if(n &lt;= 0){ break; } } return str;}위 알고리즘도 방금 전에 배웠던 알고리즘처럼 진법 변환을 이용한 것입니다. 진법 변환을 한자리씩 해나가기 전에 n에서 1씩 빼주면서 [1,2,4]라는 진법 변환용 배열의 인덱스에 맞게 접근하면 깔끔하게 124 나라에서 사용하는 숫자로 진법 변환이 됩니다.최적화한 나의 풀이최적화한 풀이가 다른 사람의 풀이와 동일하여서 생략하도록 하겠습니다." }, { "title": "기술 면접_ 데드락(Deadlock, 교착 상태)", "url": "/posts/deadlock/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 데드락, computer science, technical interview, deadlock", "date": "2021-09-11 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.데드락(Deadlock, 교착 상태) 데드락(Deadlock, 교착 상태)이란 프로세스가 자원을 얻지 못하고 계속 기다리기만 하고 있는 상태로 교착 상태라고 부르기도 합니다. 어떤 상황일 때 이런 교착 상태가 일어나는지 위 정의만 들으면 잘 이해가 안될 수 있으니 아래 그림을 보고 한번 이해해보겠습니다.어느 날 t0라는 시각에 Process1과 Process2가 각각 모두 Resource1, Resource2를 모두 점유해서 사용해야된다고 가정해보겠습니다. 이런 상황에서 Process1은 Resource1을 점유했고, Process2는 Resource2를 점유한 상태입니다. 하지만 Process1 입장에서는 Resource2가 필요하고 Process2 입장에서는 *Resource1이 추가적으로 필요한데 타 프로세스가 이미 점유하고 있는 상태라서 해당 Resource를 사용할 수 없는 상태로 무한 대기 상태에 빠지게 됩니다.바로 이러한 상태를 교착 상태, Deadlock이라고 부릅니다.데드락(Deadlock)의 발생 조건 데드락은 아래 조건 중에서 1개라도 만족할 시에 발생할 수 있습니다. 상호 배제(Mutual exclusion) 한 번에 프로세스 하나만 해당 자원을 사용할 수 있음을 뜻 합니다.즉, 어떤 프로세스가 자원을 이미 사용중이라면 요청한 자원의 점유가 해제될 때까지 기다려야만 합니다. 점유 대기(Hold and wait) 자원을 하나 이상 점유하고 있으면서 다른 프로세스에 할당된 자원을 점유하기 위해 대기하고 있는 프로세스가 존재해야 합니다. 비선점(No preemption) 이미 할당되어 있는 자원을 강제로 뺏어올 수 없습니다. 순환 대기(Circular wait) 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 합니다. 데드락(Deadlock) 해결법 데드락(Deadlock, 교착 상태)의 해결 방법을 아래와 같이 크게 3종류로 분류할 수 있습니다. 데드락이 발생하지 않도록 예방하기.(Prevention) 데드락 발생 가능성을 인정하면서 적절하게 회피하기.(Avoidance) 데드락 발생을 허용하지만 데드락을 탐지하여, 데드락으로부터 회복하기.(Detection &amp; Recovery) 데드락 예방(Prevention) 데드락의 예방 방법은 간단합니다. 앞서 배운 데드락의 발생 조건 중 하나라도 발생하지 않게 만드는 것이 예방법입니다. 즉, 총 4가지의 발생 조건 각각을 방지할 수 있는 상황들이 예방법이라고 할 수 있어요. 상호 배제를 금지 : 한 번에 여러 프로세스가 동시에 자원을 공유해서 사용할 수 있게 해주면 됩니다.=&gt; 하지만 공유 자원에 동시에 접근하게 되면 문제가 발생할 수 있으므로 동기화 처리를 해줘야 합니다. 점유 대기를 금지 : 프로세스에 필요한 자원을 요구할 때 모든 자원을 한꺼번에 요구하고 허용될 때까지 작업을 보류하면서 추후에 또다른 자원을 점유하기 위한 대기 상태를 만들지 않도록 할 수 있습니다. 비선점을 금지 : 이미 다른 프로세스에게 할당된 자원에 대한 선점권이 해당 프로세스에게 없다고 가정할 때, 우선순위가 높은 프로세스가 해당 자원을 선점할 수 있도록 해주면 됩니다. 순환 대기를 금지 : 자원을 순환 형태로 대기하지 않고 일방향적으로 자원에 대한 요구를 할 수 있도록 수정하면 됩니다. 이렇게 데드락을 예방할 수 있지만, 위와 같은 예방법을 사용하게 되면 시스템의 처리량이나 작업의 효율성을 떨어뜨리는 영향을 줄 수도 있습니다. 그래서 데드락 예방법보다 조금 덜 제한적인 데드락 회피법(Avoidance)으로 데드락 예방법의 단점을 조금 해결할 수 있습니다.데드락 회피(Avoidance) 데드락 회피법을 이해하기 위해서는 아래 2가지 핵심 키워드를 이해해야만 합니다. 안정 상태(Safe state) 시스템의 프로세스들이 요청하는 모든 자원을 데드락 없이 차례대로 모두에게 할당해줄 수 있다면 이러한 상태를 안정 상태(Safe state)에 놓여있다고 말합니다. 안정 순서(Safe sequence) 위처럼 안정 상태를 만들 수 있는 순서, 즉 특정한 순서로 프로세스들에게 자원을 할당하고 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서가 있다면 이 순서를 안정 순서(Safe sequence)라고 부릅니다. 위에 나온 개념들과 반대 되는 개념으로, 불안정 상태라는 것이 있습니다. 이름에서 알 수 있듯이 안정 상태가 아닌 상황을 말합니다. 즉, 데드락이 발생할 수 있는 상황을 뜻합니다. 데드락이 무조건 발생한다가 아니고 발생할 수 있다라는 것을 의미하기 때문에 굳이 따지자면 불안정 상태가 데드락의 집합보다 조금 더 큰 집합이라고 생각하시면 될 것 같습니다.(데드락 집합이 불안정 상태의 부분 집합이겠죠?)그말인 즉슨, 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 해주면 데드락 회피가 가능할 것입니다. 이러한 알고리즘으로 유명한 것이 은행원 알고리즘입니다.은행원 알고리즘(Banker’s Algorithm) 위 알고리즘은 다익스트라가 제안한 알고리즘입니다. 어떤 자원을 할당하기 전에 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션해서 Safe state가 유지될 수 있는지 여부를 검사하는 알고리즘입니다. 즉, 대기중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사한다고 생각하면 될 것 같습니다. 위 그림처럼 P0~P2의 프로세스가 있고, Max는 각 프로세스마다 최대 자원 요청량, Allocation은 각 프로세스 별로 현재 할당된 자원량, Need는 (Max값 - Allocation값)으로 남은 필요한 자원량이라고 정의하겠습니다.그리고 시스템에는 총 12개의 자원을 가지고 있다고 가정해보겠습니다.현재 각 프로세스에서 사용중인 자원량(Allocation)값을 모두 더해보면 5+2+2=9 입니다.그러니까, 총 12개의 자원 중에서 9개의 자원을 사용하고 있으니까 3개의 자원이 남아있는 상태입니다.이 상태에서 Safe sequence를 찾아보겠습니다. &lt;P1, P0, P2&gt; 순서로 자원이 할당될 때 Safe sequence를 만족하게 됩니다. 어렵지 않으니까 직접 해보는 것으로 하겠습니다.이렇게 한다면 자원의 부족함 없이 Safe state를 유지할 수 있습니다.**은행원 알고리즘을 간단하게 훑어보면서 누구에게 먼저 자원을 줄지도 굉장히 중요하고 자원을 줬다고 하더라도 어떤 시점에 자원을 다른 프로세스에게 주는 지도 굉장히 중요한 이슈가 됨을 알 수 있었을 겁니다. **이렇게보면 은행원 알고리즘은 결점없이 완벽하기만 알고리즘 같긴 하지만 여기에 문제점이 있습니다. 미리 최대 자원 요규량을 알아야만 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어서 제약 조건이 많습니다. 이러면서 자원 이용도 또한 하락할 수 있다는 단점이 존재하게 됩니다.데드락 탐지(Detection) 및 회복(Recovery) 데드락이 발생할 수 있음을 항상 열어두고 데드락이 발생했는지 안했는지 탐지해서, 발생했다면 회복하는 방법으로 데드락 이슈를 해결할 수도 있습니다. 데드락 탐지(Detection) Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악하는 방식입니다. 이 외에도, 자원 할당 그래프를 통해 탐지하는 방법도 있습니다. 회복(Recovery) 단순히 프로세스를 1개 이상 중단시켜서 데드락으로부터 회복시킬 수 있습니다. 크게 여기에는 2가지 방법이 있을 수 있는데, 교착 상태에 빠진 모든 프로세스를 한번에 중단시키는 방법이 있고, 프로세스를 하나씩 중단시켜 가면서 탐지 알고리즘을 통해서 데드락으로부터 회복되었는지 계속 탐색하는 방법이 있습니다. 전자의 경우 계속해서 작업중이던 프로세스들이 모두 일시에 중단되기 때문에 작업중인 부분 결과가 폐기될 수 있다는 그런 부작용이 발생할 수 있고, 후자의 경우에는 매번 탐지 알고리즘을 수행해야 한다는 점에서 전자에 비해서 부담이 되는 작업입니다. 자원 선점을 통해서 데드락으로부터 회복시켜줄 수도 있는데요, 이미 프로세스에 할당된 자원을 선점해서 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법이 있습니다. 잠깐 자원을 빌려서 교착 상태를 해결할 때까지만 쓰고 다시 되돌려주는 방식입니다. References https://chanhuiseok.github.io/posts/cs-2/" }, { "title": "기술 면접_ 페이지 교체 알고리즘", "url": "/posts/page-replacement/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 페이지 교체, computer science, technical interview, page replacement", "date": "2021-08-29 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.페이지 교체 알고리즘이란? 저번 가상 메모리 관련된 포스팅에서 페이지에 대한 개념을 배웠습니다. 페이지란 가상 메모리 시스템에서 데이터를 관리하는 기본 단위입니다. 프로세스가 실행되면서 여러 페이지들을 참조하고자 요구하게 되는데, 그때 페이지가 실제 메모리에 올라가있지 않으면 페이지 폴트가 발생했다고 말하고 참조하고자 하는 페이지를 보조 기억장치에서 가져와야만 합니다. 막상 보조 기억장치에서 우리가 찾는 페이지를 가져왔다고해도 메인 메모리가 페이지로 가득 차있으면 이미 쓰고 있는 페이지 중에 하나를 선택해서 제거해야하는데, 이때 앞으로 가장 덜 쓰일 페이지를 예측해서 제거한다면 더욱 효율적일 것입니다. 이런식으로 페이지 폴트가 최소화될 수 있도록 효율적인 알고리즘을 마련하는 것이 필요한데, 이와 관련된 알고리즘이 페이지 교체 알고리즘입니다.아래에서 그림과 함께 여러 알고리즘들을 공부할텐데, 아래 나오는 예시들은 모두 각 프로세스에 프레임을 3개로 주었다고 가정하겠습니다.즉, 한 프로세스가 사용할 페이지를 3개까지 담을 수 있는 것이라고 생각하면 됩니다.FIFO(First In First Out) 가장 간단한 알고리즘으로, 자료구조를 공부한 사람이라면 기본적으로 알고있을 알고리즘입니다.FIFO란, 가장 먼저 들어온 원소를 가장 먼저 내보내는 방식으로 한국말로하면 선입선출이라고도 합니다.자료구조로는 queue로 구현할 수 있습니다.위 그림을 보면 7 0 1 … 순으로 페이지가 들어온 것을 알 수 있습니다. 그래서 페이지 폴트가 발생해서 페이지 교체가 필요할 때 7 0 1이 순서대로 교체되는 것을 확인할 수 있습니다.이렇게 이해하기 쉽고 단순한만큼 효율성에 있어서 최적화된 알고리즘이라고 할 수는 없습니다. 단적인 예로 위 그림에서 9번째 상황을 보면 2가 페이지 폴트가 발생해서 들어오는 상항인데 바로 앞 8번째 상황까지만 해도 2가 존재했지만 FIFO 알고리즘에 의해서 교체된 것을 확인할 수 있습니다. 즉, 이렇게 활발하게 사용되고 있는 페이지일지라도 예외없이 자기 순서가 되면 가차없이 내보내집니다.최적의 페이지 교체 알고리즘이란? 그렇다면 최적의 페이지 교체 알고리즘은 무엇일까요? 우리는 FIFO 알고리즘을 예시로 보면서 대충 눈치를 챌 수 있었습니다. 바로 앞으로 쓰일 페이지는 메모리에 그대로 놔두고, 앞으로 안쓰일 페이지들을 순서대로 먼저 내보내면 될 것 입니다. 하지만 이 알고리즘은 이론상으로만 가능한 이야기입니다.왜냐하면, 앞으로 어떤 페이지가 많이 쓰이고 앞으로 어떤 페이지는 덜 쓰일지는 미래에 갔다오지 않는 이상 예측으로만 가능한 이야기기 때문입니다. 그래서 이 알고리즘은 연구 목적으로만 사용이 되고 이 알고리즘을 따라하는 비슷한 알고리즘들이 존재합니다. 아래에서 더욱 알아보도록 하겠습니다.LRU(Least-Recently-Used) 최적의 페이지 교체 알고리즘(Optimal page replacement algorithm)과 비슷한 성능을 내기 위해 개발된 알고리즘으로 LRU(Least-Recently-Used)란 알고리즘이 있습니다. 최적의 알고리즘에서 얘기했듯이 우리는 가장 안쓰일 녀석들을 예측하는 것만이 최선의 방법이 될 수 있습니다.LRU는 최근에 가장 안쓰인 녀석들이 앞으로도 가장 안쓰일 것이라고 예측하는 방법입니다. 그래서 가장 오랜 기간동안 사용되지 않은 페이지를 교체 1순위로 삼는 것 입니다. 위 그림을 통해 이해해보면 좋을 것 같습니다.LRU 알고리즘은 성능이 어느정도 입증되어있는 상태라서 실제로 많은 운영체제에서 사용하고 있는 알고리즘이고 좋은 알고리즘이라고 평가받고 있습니다.계수-기반(Counting-Based) 페이지 교체 LRU 알고리즘을 기반으로 하지만 페이지가 참조될 때마다 해당 페이지가 몇번이나 참조되었는 지를 확인하기 위해서 지속적으로 Counting을 하고 그 값을 기반으로 페이지 교체 우선 순위를 결정하는 알고리즘이 있습니다. 이를 계수-기반(Counting-Based) 페이지 교체 알고리즘이라고 하는데, Counting-Based 알고리즘의 대표적인 예시 LFU(Least-Frequently-Used)와 MFU(Most-Frequently-Used)에 대해 알아보겠습니다.LFU(Least-Frequently-Used) LFU는 Couting-Based 페이지 교체 알고리즘의 일종입니다. 기본적으로 LRU(Least-Recently-Used)알고리즘을 기반으로 하고 있습니다. 참조 횟수를 계속해서 세면서 그때 그때 참조 횟수가 가장 작은 녀석을 내보내는 알고리즘입니다.이 LFU에는 치명적인 단점이 하나 존재하는데, 특정 페이지를 초반에만 많이 참조하고 나중에 안쓰는 경우에 비효율적일 수 있습니다. 바로 아래와 같은 상황처럼 말입니다.MFU(Most-Frequently-Used) MFU 역시 Counting-Based 알고리즘의 일종인데, LFU와 반대 개념이라고 생각하시면 됩니다. 참조 횟수가 가장 많은 페이지를 1순위 교체 대상으로 삼는 알고리즘입니다. 참조 횟수가 적은 페이지들은 최근에 사용된 페이지이기 때문에 앞으로도 사용될 가능성이 높다고 판단하는 것 입니다.이렇게 Counting-Based 알고리즘의 예시 2개로 LFU, MFU까지 다뤄봤는데, 사실 위 2개의 알고리즘은 실제로 잘 쓰이지 않습니다. 왜냐하면 구현하기가 상당히 까다롭고 LRU에 비해서 최적의 페이지 교체 알고리즘을 유사하게 구현해내지 못하기 때문입니다. 그래서 일반적으로는 LRU 알고리즘을 가장 많이 쓴다고 알고 계시면 될 것 같습니다.References https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b" }, { "title": "고득점 Kit_ 탐욕법 - Level2 - 구명보트", "url": "/posts/lifeboat/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, greedy, 고득점, 구명보트, 탐욕법, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-29 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 구명보트 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; people, int limit){ int answer = 0; int head = 0; int tail = people.size() - 1; sort(people.begin(), people.end()); while (head &lt;= tail) { if (head == tail) return ++answer; if (people[head] + people[tail] &gt; limit) { answer++; tail--; continue; } answer++; head++; tail--; } return answer;}이번 문제를 마지막으로 프로그래머스 고득점 kit Level1 ~ Level2까지 모든 문제를 다 풀어보았습니다.우선 vector.erase()로 처리하는 시간도 아깝고 그럴 필요도 없기 때문에 vector의 양 끝 인덱스를 가리키는 포인터와 같은 변수 head, tail을 사용하였습니다.핵심 로직은 다음과 같습니다. 최소 무게를 가지는 사람과 최대 무게를 가지는 사람을 더했을 때 limit를 넘어버리게 되면 그 최대 무게를 가지는 사람은 그 누구와도 함께 보트를 탈 수 없습니다.위와 같은 상황이 나오게되면 최대 무게를 가지는 사람을 혼자 보트를 태워 보내면 되고, limit를 넘지 않는 쌍이 나오면 같이 태워보내면 됩니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; people, int limit){ sort(people.begin(), people.end()); reverse(people.begin(), people.end()); int N = (int)people.size(); int res = 0; for (int i = 0, j = N - 1; i &lt;= j; i++) { if (people[i] + people[j] &lt;= limit) { j--; } res++; } return res;}위 알고리즘이 프로그래머스 내에서 가장 많은 추천을 받은 풀이입니다. 저와 로직 자체는 매우 똑같은데 저보다 엄청 코드가 효율적이고 이쁘게 잘 짜여져 있어요.어려운 코드는 아닙니다만, 제가 다중 if 혹은 if-else문으로 처리한 것을 이쁘게 한개의 if문으로 처리했다고 보시면 됩니다.특이 사항으로는 sort를 한 뒤에 reverse를해서 내림차순으로 정렬을 해주셨는데 사실 아래처럼 한번에 처리해주셔도 괜찮지 않았나라는 생각을 해봅니다.sort(people.begin(), people.end(), greater&lt;int&gt;());다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; people, int limit){ sort(people.begin(), people.end()); int maxPeopleIdx = people.size() - 1; int minPeopleIdx = 0; while (maxPeopleIdx &gt; minPeopleIdx) { if (people[maxPeopleIdx--] + people[minPeopleIdx] &lt;= limit) ++minPeopleIdx; } int answer = people.size() - minPeopleIdx; return answer;}위 알고리즘도 로직 자체는 매우 동일합니다. 그냥 while문 안에 if문 구성이 조금 다르다 정도? 그중에서 나름 뚜렷한 차이점이 하나 있는데 while()문을 돌면서 answer에 증감을 하지 않습니다. 마지막에 루프를 다 돌고나서 벡터 전체 사이즈에서 minPeopleIdx를 빼주면서 계산을 합니다.최적화한 나의 풀이최적화한 풀이가 다른 사람의 풀이와 동일하여서 생략하도록 하겠습니다." }, { "title": "고득점 Kit_ 스택/큐 - Level2 - 주식가격", "url": "/posts/price-of-stock/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, stack, queue, 고득점, 주식가격, 스택, 큐, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-28 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 주식가격 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; prices){ vector&lt;int&gt; answer(prices.size(), -1); stack&lt;int&gt; s; stack&lt;int&gt; index; s.push(-1); for (int i = 0; i &lt; prices.size(); i++) { if (s.top() &gt; prices[i]) { while (s.top() &gt; prices[i]) { int tempIndex = index.top(); answer[tempIndex] = i - tempIndex; s.pop(); index.pop(); } s.push(prices[i]); index.push(i); } else { s.push(prices[i]); index.push(i); } } for (int i = 0; i &lt; answer.size(); i++) { if (answer[i] == -1) { answer[i] = answer.size() - i - 1; } } return answer;}오늘은 스택/큐와 관련된 문제입니다. 출제 빈도가 높은 단골 유형입니다.제 알고리즘을 보시면 아시겠지만, 저는 스택 2개를 만들어서 문제를 풀이하였습니다. 뒤이어 나오는 다른 사람의 풀이1처럼 스택 1개만 가지고 훨씬 간결하고 직관적으로 풀이 할 수 있습니다.풀이 자체는 되게 간단합니다. prices 배열의 원소인 주식 가격을 순서대로 차곡차곡 담아줄 s와, 해당 주식가격과 매핑되는 인덱스도 순서대로 차곡차곡 담아줄 index를 선언해줬고 둘 다 자료구조는 stack을 사용했습니다. LIFO 구조가 필요했기 때문입니다. 주식 가격과 해당 가격에 매핑되는 인덱스로 pair로 매핑해줄까 하였지만, 급히 풀어서 그런지 그냥 index만으로 접근할 생각을 미처 못했습니다.네, 그 다음에 핵심 로직은 스택 탑에 있는 주식 가격과 현재 들어와야할 주식 가격을 비교해서 들어올 주식 가격이 더 크면(이 시점이 주식 가격이 떨어지는 시점일 것입니다.) 그때부터는 주식 가격이 더 크거나 같은 값이 나올 때까지 stack pop() 해주면 됩니다.제 알고리즘에선 index 관련된 정보는 index라는 stack에서 따로 저장하고 관리하고 있기 때문에 stack s에서 pop(), push()가 일어나면 index stack에서도 모두 동일하게 처리 해줘야 합니다.위 풀이에서 맨 마지막 for 루프에 -1 부분에 관하여 설명드리자면, answer를 시작하기 전부터 모두 -1로 초기화 시켜놓고 answer에 변화가 생기면(-1이 아니면) 알고리즘을 거쳐서 적절한 답들로 변경되었다고 처리를 해준겁니다. 위 루프를 거쳐도 -1이라면, 끝까지 가격이 떨어지지 않고 살아남은 친구들이기 때문에 후처리를 해준 것입니다.다음 풀이로 넘어가기 전에 stack 자료 구조에 대해서 짚어봅시다.stack이란? LIFO(Last In First Out) 구조로 이루어져 있으며 C++에서는 stack이라는 헤더파일 내에 들어 있습니다. stack.top()이라는 메소드를 통해서 top에 있는 원소를 참조할 수 있고 stack.pop()을 통해서 최상단의 원소를 지워낼 수 있습니다. stack.pop()을하면 리턴값으로 pop()처럼 stack top에 있는 원소가 리턴된다고 생각하기 쉽지만 그렇지 않으므로 주의하시길 바랍니다.그 이외에도 스택에 원소를 넣어주는 stack.push()스택이 비어있는지 확인해 주는 stack.empty()스택 사이즈를 리턴해주는 stack.size() 등이 있습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; prices){ vector&lt;int&gt; answer(prices.size()); stack&lt;int&gt; s; int size = prices.size(); for (int i = 0; i &lt; size; i++) { while (!s.empty() &amp;&amp; prices[s.top()] &gt; prices[i]) { answer[s.top()] = i - s.top(); s.pop(); } s.push(i); } while (!s.empty()) { answer[s.top()] = size - s.top() - 1; s.pop(); } return answer;}위 알고리즘이 프로그래머스 내에서 가장 많은 추천을 받은 풀이입니다. 제 로직과 굉장히 비슷하고 stack을 활용한 것도 똑같습니다. 하지만 저보다 훨씬 직관적이고 효율적입니다. 왜냐하면 저는 index를 따로 관리하려고 stack을 하나 더 만들어서 총 2개의 stack을 사용했기 때문입니다.근데 위 알고리즘처럼 인덱스를 stack에 저장하면 index를 통해 prices에 접근해서 주식 가격도 얻을 수 있고, index도 그대로 활용할 수 있어서 훨씬 효율적입니다.그리고 제 알고리즘에서 if-else 문으로 pop()+push(), push()를 나누어서 처리를 해줬다면 위 알고리즘에서는 깔끔하게 1개의 while()문과 push()로 잘 짜주었습니다.그 외의 로직은 상당히 비슷하기 때문에 생략하도록 하겠습니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; prices){ vector&lt;int&gt; answer; int size = prices.size(); for (int i = 0; i &lt; size; i++) { int time = 0; for (int j = i + 1; j &lt; size; j++) { time++; if (prices[j] &lt; prices[i] || j == size - 1) { //마지막에서 두번째 값은 만약 마지막 값이 더 크다면 push할 수가 없기때문에 조건에 추가 answer.push_back(time); break; } } } answer.push_back(0); //마지막은 시간이 없음 return answer;}위 알고리즘은 이중 포문을 활용한 풀이입니다. 크게 이 문제는 이중 포문 혹은 stack을 활용한 풀이 이렇게 2가지로 나뉩니다. 이 알고리즘은 더 이해하기가 쉽습니다. 앞에 원소부터 차례차례 이중 포문을 돌면서 time을 늘려가면서 문제 조건에 부합하는 원소를 찾고 해당 원소가 나오면 answer에 바로 푸시합니다. 근데 포문들을 끝까지 돌았는데 조건에 부합하는 원소들이 있을 수 있습니다. 해당 경우를 대비해 if문에 j == size-1로 처리해준 것을 볼 수 있습니다.최적화한 나의 풀이최적화한 풀이가 다른 사람의 풀이와 동일하여 생략하도록 하겠습니다.References https://twpower.github.io/75-how-to-use-stack-in-cpp" }, { "title": "고득점 Kit_ 탐욕법 - Level2 - 큰 수 만들기", "url": "/posts/making-big-number/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, greedy, 고득점, 큰 수 만들기, 탐욕법, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-26 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 큰 수 만들기 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;string solution(string number, int k){ string answer = \"\"; int size = number.size() - k; int i = 1; auto it = number.begin(); while (answer.size() != size) { it = max_element(it, number.end() - (size - i)); answer += *(it++); i++; } return answer;}위 문제를 풀 때 주의할 점은 parameter로 넘겨받는 number에서 숫자를 제거만 할 뿐, 더 큰 숫자를 만들기 위해서 재배열을 할 수는 없다는 점입니다. 즉 숫자들 사이에 이미 순서는 고정되어 있다는 점k는 제거할 숫자의 개수를 나타냅니다. numbers에 들어있는 총 숫자의 개수가 n이라고 해봅시다. 그러면, 제거할 거 다 제거한 뒤에 최종 답인 answer의 size()는 n-k가 될 것입니다.numbers 내부적으로 숫자들 간의 순서는 고정되어 있기 때문에 앞쪽에 있는 인덱스의 숫자가 최대값이 되어야 최종적인 answer도 최대값이 될 수 있을것 입니다.즉, numbers 내에서 Max값을 찾아줄겁니다. 그런데 여기서 중요한 점이 있습니다.만약에 max값을 찾았는데 이 max가 뒤쪽 인덱스에 위치하고 있다면? 그래서 max 기준으로 뒤에 있는 모든 원소를 지우지 않고 살려 놓아도 answer.size()인 반드시 n-k보다 작게된다면? 그건 max로 쓸 수 없을 것입니다. 그래서 저는 0번째 인덱스부터 -n+k+i 미만의 원소 중에서 max_element()를 통해서 최대값을 찾아줄 것이고, 최대값의 이터레이터를 알게 되면 최대값 앞에 있는 모든 원소들은 제거 해줄 것 입니다. 근데 저는 제거해주는 시간조차 아깝다고 생각해서 실제로 원소를 제거하지는 않고 it의 위치만 바꿔주면서 마치 제거한 것처럼 처리하였습니다.max_element()란? C++ algorithm 라이브러리 내에 존재하는 최대값을 찾아주는, 정확히 말하면 최대값을 가지는 원소의 위치(이터레이터)를 리턴해주는 메소드입니다. 이전 포스팅에서도 몇번씩 보셨을거라고 생각합니다.보통은 max_element(v.begin(), v.end());이런 식으로 벡터와 함께 많이쓰고, [v.begin(), v.end()) 범위 내에서 최대값을 찾아준답니다.이번 알고리즘 문제에서는 벡터가 아니고 string 객체의 이터레이터를 활용해서 사용해주었습니다.최소값을 구해주는 min_element()도 있으니까 참고하시면 좋을 것 같습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;string solution(string number, int k){ string answer = \"\"; answer = number.substr(k); for (int i = k - 1; i &gt;= 0; i--) { int j = 0; do { if (number[i] &gt;= answer[j]) { char temp = answer[j]; answer[j] = number[i]; number[i] = temp; j++; } else { break; } } while (1); } return answer;}위 풀이는 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 처음에 위 풀이를 봤을 때 너무 막막했습니다. 왜냐하면, for()문 안에 do while()문을 보는데 딱봐도 j가 지정된 인덱스를 벗어날 것만 같은 기분이 드는겁니다. 그래서, 위 알고리즘을 뜯어보기 전에 여러가지 테스트 케이스를 위 코드로 돌려봤습니다. 근데 완벽하게 정답.. 정답 … 제 예상 혹은 걱정과 달리 위 코드는 아주 정상적으로 잘 작동했습니다. 오랜 시간 고민한 결과 그 이유를 알아냈습니다. 같이 한번 살펴봅시다.우선 위 알고리즘에 대한 이해가 필요합니다.answer = number.substr(k);이 부분에서 answer에 임의의 부분 문자열을 넣어놓습니다. 여기서 중요한 것이 있는데 그 전에 substr()이 어떻게 동작하는 지 알아봅시다.substr()이란? string 클래스에 내장되어 있는 메소드로 부분 문자열을 리턴해주는 함수입니다. 정확히는 [pos, pos+count) 내의 부분 문자열을 리턴해줍니다. 원형은 아래와 같이 생겼습니다. basic_string substr(size_type pos = 0, size_type count = npos) const; 이렇게 원형만 놓고보면 이해도 잘 안되고 어려워보이니까 간단히 설명드리도록 하겠습니다.보시면 알겠지만 pos, count라는 parameter를 총 2개 받고 있고, pos, count의 Default값으로 각각 0과 npos가 설정되어 있습니다. count에 npos가 전달되면 자동으로 pos부터 문자열 끝까지 리턴하게 되어있습니다. 아래 예제 케이스들을 보시면 더욱 이해가 잘 되실겁니다. // count가 npos 이므로 pos부터 문자열 끝까지 리턴한다. std::string sub1 = a.substr(10); // pos와 pos + count 모두 문자열 범위 안이므로, 해당하는 부분 문자열을 리턴한다. std::string sub2 = a.substr(5, 3); // pos는 문자열 범위 안이지만, pos+count는 밖이므로, pos부터 문자열 끝까지 리턴한다. std::string sub4 = a.substr(a.size() - 3, 50); // pos 가 문자열 범위 밖이므로 예외를 발생시킴. std::string sub5 = a.substr(a.size() + 3, 50);자 다시 알고리즘 풀이로 돌아와서, 그러면 아까 해당 코드 부분을 다시 보겠습니다.answer = number.substr(k);그러면 이 말인즉슨, index k부터 마지막 원소까지를 부분 문자열로 리턴하겠다는 말일 것입니다.이렇게 되면 최종적으로 구해야하는 answer의 size()와 같은 길이를 가지는 string 객체가 answer에 들어가게 되는거입니다. 이제 for()문을 들어가서 방금 만든 부분 문자열의 바로 왼쪽에 인덱스부터 시작하여 최대값을 찾아 탐색을 떠납니다. 그러다가 do while()문에 들어가게 됩니다. 만약 왼쪽에 인덱스에서 더 큰 값이 발견되면 Swap()을 해주고 j를 1개 늘려줍니다. 이걸 늘리는 이유는, 방금 교체된 즉 answer안에 들어있던 그 원소가 다음 최대값이 될 수도 있으니까 answer내 나머지 원소들과도 모두 비교를 해주는 것 입니다. 그런데 여기서 문제가 생깁니다. 이렇게 하다보면 분명히 100%, 아니 200% answer.size()를 넘어가는 out of range 문제가 생겨버립니다. 제가 걱정했던 부분이 바로 이 부분입니다. 근데 결론부터 말씀드리면 문제가 없습니다.그 이유는 저희가 다루는건 string 클래스의 객체입니다. 이렇게 대괄호를 써서 index로 접근하고 값 변경을 할 수도 있습니다. 하지만 index로 값을 넣어주고 한다고 해서 string 객체의 size()가 변하지는 않습니다. 즉, 우리가 return하는 string answer의 size는 변하지 않는 것입니다. 제가 size를 넘어가는 범위에서 어떤 행동을 하건 그것은 제가 리턴하는 string answer에 영향을 미칠 수가 없습니다. cout으로 아무리 출력을 백번 천번 해봐도 answer.size()내의 결과값만 출력될 뿐입니다.그렇다고 해서 string 내 오버라이딩 된 ‘+’ 연산자도 똑같이 생각하시면 안됩니다. ’+’ 연산자는 두 문자열이 합쳐지고 하나의 새로운 크기의 문자열이 탄생하게 되어있습니다. 즉 해당 연산자를 사용하면 string의 size()도 알맞게 재조정이 됩니다. 그렇게되면 우리가 원하는 answer.size()가 바뀌는 경우도 생길 것입니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string solution(string number, int k){ for (int i = 0; i &lt; number.size() - k; ++i) { auto iter = std::max_element(number.begin() + i, number.begin() + i + k + 1); if (iter != number.begin() + i) { k = k - std::distance(number.begin() + i, iter); number.erase(number.begin() + i, iter); } } number.erase(number.end() - k, number.end()); return number;}위 알고리즘도 프로그래머스 상에서 많은 추천을 받은 풀이인데, 제 알고리즘과 가장 비슷한 풀이입니다. 큰 알고리즘은 거의 동일하고 하나 다르다면 이 알고리즘에서는 erase를 사용해서 진짜 원소들을 지워주면서 풀이하고 있습니다. 그래서 max_element() 등과 같은 곳에서 접근하고 있는 이터레이터들이 조금씩 다릅니다. 그 외에는 완전 동일해서 추가적인 풀이는 생략하도록 하겠습니다.최적화한 나의 풀이최적화한 풀이가 처음에 푼 풀이와 동일하므로 마찬가지로 생략하도록 하겠습니다.References https://m.blog.naver.com/kks227/220246803499https://modoocode.com/235" }, { "title": "고득점 Kit_ 정렬 - Level2 - H-Index", "url": "/posts/h-index/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, sort, 고득점, h-index, 정렬, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-25 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - H-Index 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; citations){ int answer = 0; sort(citations.begin(), citations.end()); for (int i = 0; i &lt; 10001; i++) { int more = citations.size() - (lower_bound(citations.begin(), citations.end(), i) - citations.begin()); if (i &lt;= more &amp;&amp; citations.size() - more &lt;= i) answer &lt; i ? answer = i : 1; } return answer;}밤 늦게 침대에서 안풀리면 내일 풀지라는 생각으로 풀어서 그런지 코드가 좀 효율적이지 못한 부분이 바로 보입니다. for문에서 보시면 10000번이나 루프를 돌리는데 그럴 필요 전혀 없습니다. citations.size()만큼만 돌려도 됩니다. 이유는 아래에 있습니다.자 일단 이 문제, 꼼꼼하게 읽지 않으면 헷갈리기 아주 쉽게 적혀있습니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.문제 조건이 위처럼 주어져있습니다. 근데 사실 여기에는 당연한 말이 들어있습니다. 필요 없는 문장이 헷갈리게 들어가 있단 말입니다.h번 이상 인용된 논문이 h편 이상이면, 나머지 논문은 당연히 h번 이하 인용되어 있을 것 입니다.여기서 더 나아가서 “h번 이상 인용된 논문이 h편이다.” 라는 조건에서 당연하게도 h는 n보다 클 수 없음을 알 수 있습니다. 즉, 위에 제 for문을 citations.size()+1만큼만 돌려도 충분하다는 것을 알 수 있습니다. 여기서 주의할 것은 i가 citations.size()까지도 될 수 있어야 합니다.lower_bound()란? 이전 포스팅에서도 몇번씩 사용되었던 C++ algorithm 내에 lower_bound()라는 메소드입니다. 이 메소드는 아래와 같이 사용됩니다. lower_bound(v.begin(), v.end(), key); 즉, 범위의 시작과 끝을 [v.begin(), v.end())와 같이 정해주고 그 범위 내에 key값보다 같거나 큰 값이 처음으로 나오는 이터레이터를 리턴해주는 메소드입니다.단, 주의할 점으로 위 메소드와 반대의 기능을 하는 upper_bound() 메소드 모두 오름차순 정렬이 되어 있어야 사용할 수 있습니다.왜냐하면 위 메소드는 이진탐색으로 이루어져있기 때문입니다. 그래서 시간 복잡도는 O(logN)입니다.저는 오름차순으로 citations를 정렬한 뒤에 이렇게 lower_bound를 활용했고 for문의 제어 변수인 i를 하나씩 증가시켜가면서 H-Index의 조건에 맞는 i를 찾았습니다. i보다 크거나 같은 값이 처음으로 나타나는 곳의 이터레이터를 lower_bound로 구할 수 있기 때문에 citations.size()에서 해당하는 인덱스를 빼주면 제가 찾던 Key값 이상의 값을 가지는 원소의 개수를 바로 구할 수 있습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; citations){ sort(citations.begin(), citations.end(), greater&lt;int&gt;()); for (int i = 0; i &lt; citations.size(); ++i) { if (citations[i] &lt; i + 1) { return i; } } return citations.size();}위 풀이는 프로그래머스에서 가장 많은 추천을 받은 알고리즘입니다. 위 코드는 정말 잘 짜여진 코드입니다.if(citations[i] &lt; i+1){\treturn i;}위 코드에서 citations[i] &lt; i+1 부분을 &lt;= 부등호로 바꿔봅시다. 그리고 프로그래머스에 정답 제출을 해보시면 정답으로 나와요. 하지만, 문제에서 주어진 테스트 케이스 예제 1개는 통과하지 못합니다.그 이유는 바로 return i에 있습니다. 부등호 &lt; 를 사용해야지만 모든 케이스에 적합한 i가 리턴될 수 있습니다.저처럼 lower_bound를 사용하면 이런 부등호에 신경을 덜 써도 됩니다. 이렇게 부등호에 등호 하나 차이로 답이 극명하게 갈리는 이유는 바로 내림차순으로 정렬되어 있어서 그 뒤의 인덱스를 가지는 원소들이 현재 탐색중인 원소와 동일한 값을 가지는 경우가 있기 때문입니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; citations){ int answer = 0; std::sort(citations.begin(), citations.end()); for (int i = 0; i &lt; citations.size(); i++) { if (citations.size() - i &lt;= citations[i]) { answer = citations.size() - i; break; } } return answer;}위 풀이도 다른 사람의 풀이1과 유사하지만, 위 사람은 내림차순을 한 뒤에 풀이한 방식입니다.내림 차순을 이용했기 때문에 다음 인덱스의 원소도 현재 탐색중인 원소의 값과 같거나 큰 값을 가짐이 보장된다고 할 수 있습니다.최적화한 나의 풀이최적화한 풀이가 다른 사람의 풀이1과 동일하여서 생략하겠습니다.References https://chanhuiseok.github.io/posts/algo-55/" }, { "title": "고득점 Kit_ 완전탐색 - Level2 - 카펫", "url": "/posts/carpet/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, exhaustive search, 고득점, 카펫, 완전탐색, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-25 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 카펫 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; solution(int brown, int yellow){ vector&lt;int&gt; answer; for (int i = 1; i &lt;= static_cast&lt;int&gt;(sqrt(yellow)); i++) { if (yellow % i == 0) { if (brown == ((yellow / i) + i) * 2 + 4) { answer.push_back(yellow / i + 2); answer.push_back(i + 2); } } } return answer;}우선 그림을 몇개 그려보고 문제 접근을 어떻게 해야할지 결정을 내렸습니다. 저는 yellow를 집중 공략하기로 했습니다. yellow의 가로, 세로 길이가 나오면 brown의 가로, 세로 길이도 결정된다는 걸 깨닫고 yellow가 가질 수 있는 모든 가로, 세로 길이를 구하기로 한 것입니다.문제에서 가로 길이가 세로 길이보다 길거나 같아야 된다고 했으므로 저는 제곱근 메소드인 cmath의 sqrt를 활용해서 yellow가 가질 수 있는 가로, 세로 값들을 구했고 이를 통해 brown 값을 계산해서 비교해주는 방식으로 풀이했습니다.static_cast&lt;int&gt;란? static_cast&lt;&gt;란 형변환을 도와주는 정적 캐스트 연산자입니다. 정적이라는 이름 답게 컴파일 시간에 형변환이 올바르게 가능한지 검사합니다. 그래서 런타임 시에 에러가 발생할 것 같으면 컴파일 시간에 미리 검사해서 에러를 발생시킵니다.이와 반대로 dynamic_cast&lt;&gt;와 같은 동적 캐스트 연산자도 있는데 이름에 걸맞게 런타임 시간에 형변환에 대한 안정성을 검사합니다. 큰 차이점으로는 dynamic_cast&lt;&gt;는 기본 자료형 간의 형변환은 지원하지 않습니다. 그러니까 기본 자료형 간의 형변환을 할 때는 반드시 static_cast&lt;&gt;를 사용해줘야 합니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; solution(int brown, int red){ int len = brown / 2 + 2; int w = len - 3; int h = 3; while (w &gt;= h) { if (w * h == (brown + red)) break; w--; h++; } return vector&lt;int&gt;{w, h};}위 알고리즘은 프로그래머스에서 가장 많은 추천을 받은 풀이입니다. 우선 brown을 통해서 brown의 가로 + 세로 길이인 len를 구해줬고, brown의 초기 세로 길이를 3으로 고정시킵니다. 숫자가 3인 이유는 yellow가 1개일 때 최소로 가져야만 하는 가로 세로 길이가 3이기 때문입니다. 그래서 최소값으로 지정해준 거 뿐입니다. 세로 길이가 최소값이므로 가로 길이는 최대값을 가질 것 입니다. 그래서 while 루프를 돌면서 가로 길이는 1개씩 줄여주고 세로길이는 하나씩 늘려주고 있습니다. 그러면서 정답을 찾아가는 방식입니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; solution(int brown, int yellow){ vector&lt;int&gt; answer; int x = 2; int y = brown / 2 - x; while (1) { if ((x - 1) * (y - 1) == yellow) break; x++; y--; } answer.push_back(y + 1); answer.push_back(x + 1); return answer;}이 풀이도 위의 풀이와 많이 비슷합니다. x라는 변수를 2라고 설정했는데 이건 brown의 세로 길이에서 1을 뺀 길이라고 봐야합니다. y는 brown의 가로 길이에서 1을 뺀 길이입니다.이렇게 구한 x,y에서 각각 1씩 더 빼게되면 그 값은 바로 yellow의 가로 세로 길이를 의미 합니다. 나머지 로직은 위와 동일하여 생략하겠습니다.최적화한 나의 풀이최적화한 풀이가 처음에 푼 풀이와 동일하므로 마찬가지로 생략하도록 하겠습니다.References https://mynameisdabin.tistory.com/20" }, { "title": "고득점 Kit_ 스택/큐 - Level2 - 다리를 지나는 트럭", "url": "/posts/passing-truck/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, stack, queue, 고득점, 다리를 지나는 트럭, 스택, 큐, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-24 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 다리를 지나는 트럭 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(int bridge_length, int weight, vector&lt;int&gt; truck_weights){ int answer = 0; queue&lt;int&gt; entryTime; //트럭이 완전히 올라갔을 때 진입 시간을 기준으로 저장 queue&lt;int&gt; truckOnBridge; //올라가있는 트럭들 for (int i = 1; i; i++) { //i가 여기서 timer 역할을 함 if (i == entryTime.front() + bridge_length) { weight += truckOnBridge.front(); truckOnBridge.pop(); entryTime.pop(); } if (weight - truck_weights[0] &gt;= 0) { entryTime.push(i); weight -= truck_weights[0]; truckOnBridge.push(truck_weights[0]); truck_weights.erase(truck_weights.begin()); if (truck_weights.size() == 0) return answer = i + bridge_length; } }}지난번 위장 문제를 풀면서 크게 느꼈던 효율적인 알고리즘에 대한 고민을 이번엔 깊게 하면서 위 문제는 어떻게 풀면 효율적인 로직이 나올 수 있을까를 가장 먼저 고민하였습니다. 그 결과, 위 문제에서 “트럭이 지나가는 순서가 정해져있으며 속도도 1초당 1로 모두 같으므로 트럭끼리 다리 위에서 역전될 일이 전혀 없으며 리턴 해야하는 결과값은 단지 시간 뿐이다.”라는 것을 알게 되었습니다. 따라서 저는 FIFO 구조인 queue를 사용해야겠다고 생각했고, 거기서 더 나아가서 마지막으로 다리에 올라오는 트럭의 진입 시간을 알게되면 “해당 시간 + bridge_length”로 바로 정답을 구할 수 있음을 깨달았습니다.그래서 제 알고리즘을 보면, 진입 시간을 저장할 entryTime, 추후에 트럭이 다리에서 빠져나갈 때 얼마만큼의 무게를 가지는 트럭이 빠져나가는 지 알기 위해 올라가 있는 트럭들의 무게를 저장하는 truckOnBridge라는 2개의 queue를 활용하여 풀게됩니다.(추후 최적화한 알고리즘에서는 truckOnBridge라는 queue도 공간적 낭비가 있을 수 있음을 깨닫고 int형의 인덱스 포인터 2개로 대체하였습니다.)또 핵심적인 로직이라면 for()문속 i라는 제어 변수를 마치 시간을 재는 timer 마냥 사용하면서 1초가 지나갈 때마다 다리 위에서 나가는 트럭은 없는지, 다리 위에 새로 진입하는 트럭은 없는지 검사합니다. 그러다가도 마지막 트럭이 진입하면 곧바로 결과값을 리턴하면서 비효율적으로 돌만한 loop를 최소화 시켰습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(int bridge_length, int weight, vector&lt;int&gt; truck_weights){ int answer = 0; int tot_w = 0; int t_front = 0; int t_cur = 0; int sec = 0; queue&lt;int&gt; q; while (t_front != truck_weights.size()) { if (!q.empty() &amp;&amp; (sec - q.front() == bridge_length)) { tot_w -= truck_weights[t_front]; ++t_front; q.pop(); } if (t_cur != truck_weights.size() &amp;&amp; tot_w + truck_weights[t_cur] &lt;= weight) { tot_w += truck_weights[t_cur]; ++t_cur; q.push(sec); } ++sec; } answer = sec; return answer;}위 풀이가 프로그래머스에서 가장 많은 추천을 받은 풀이입니다. 제 풀이의 로직과 굉장히 유사하지만,다른 점으로는 truckOnBridge라는 queue대신 t_front, t_cur라는 index 포인터 역할을 하는 int형 type을 사용하면서 공간적 낭비를 최소화 하였습니다. 또한 위처럼 int 포인터를 사용하게 되면 제 알고리즘처럼 vector 내 erase 메소드를 사용할 필요도 없어지게 됩니다.위와 반대로 저보다 효율적이지 못한 부분도 존재하는데요, 바로 while()문에서 마지막 진입한 트럭을 찾았음에도 불구하고 sec를 계속해서 늘려가면서 마지막 트럭이 빠져나갈 때까지 반복문을 계속 돌린다는 점입니다. 굳이 이럴 필요 없이 저처럼 마지막 트럭을 찾게되면, “마지막 트럭의 진입 시간 + bridge_length”를 리턴해주면 비효율적인 loop를 최소화 시킬 수 있습니다.다른 사람의 풀이2#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // greater 사용 위해 필요#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(int bridge_length, int weight, vector&lt;int&gt; truck_weights){ int answer = 0; int count = 0; int Time = 0; int Truck_weight = 0; queue&lt;pair&lt;int, int&gt;&gt; truck_move; while (true) { if (weight &gt;= Truck_weight + truck_weights.at(count)) { truck_move.push(make_pair(truck_weights.at(count), bridge_length + 1 + Time)); Truck_weight += truck_weights.at(count); count++; } if (count &gt;= truck_weights.size()) { answer = truck_move.back().second; break; } else { Time++; if (truck_move.front().second == Time + 1) { Truck_weight -= truck_move.front().first; truck_move.pop(); } } } return answer;}위 풀이도 대부분의 풀이와 유사하지만, queue에 pair 타입을 사용했다는 점이 이색적이어서 참고 삼아 가져와 봤습니다. 그 외의 로직에 대한 설명은 매우 비슷하기 때문에 생략하겠습니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(int bridge_length, int weight, vector&lt;int&gt; truck_weights){ int answer = 0; int firstTruck = 0; //다리 위 기준 가장 앞에 있는 트럭 인덱스 int currentTruck = 0; //앞으로 다리 위로 가장 먼저 올라갈 트럭 인덱스 queue&lt;int&gt; entryTime; //트럭이 완전히 올라갔을 때 진입 시간을 기준으로 저장 for (int i = 1; i; i++) { //i가 여기서 timer 역할을 함 if (i == entryTime.front() + bridge_length) { weight += truck_weights[firstTruck]; entryTime.pop(); firstTruck++; } if (weight - truck_weights[currentTruck] &gt;= 0) { entryTime.push(i); weight -= truck_weights[currentTruck]; currentTruck++; if (currentTruck == truck_weights.size()) return answer = i + bridge_length; } }}앞서 언급됐던 알고리즘들의 장점이라고 생각한 부분들만 모아서 짜본 최적화 알고리즘입니다. 저처럼 queue를 2개 사용하는 것은 공간적인 측면에서 비효율적이라고 생각해서 queue 1개와 int type의 포인터 2개를 사용했고, for문은 기존의 제 알고리즘과 동일하게 작성하였습니다." }, { "title": "기술 면접_ 가상 메모리와 페이지 폴트", "url": "/posts/vm-pf/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 가상 메모리, 페이지 폴트, computer science, technical interview, virtual memory, page fault", "date": "2021-08-23 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.가상 메모리란? 보조 기억장치에 비해 상대적으로 작은 크기를 가지고 있는 메모리를, 더욱 더 효율적이고 대용량으로 사용하기 위해 사용하는 기술입니다.특정 시점마다 실제 사용하는 메모리는 그렇게 크지 않다는 점에 착안해서 고안된 기술입니다.이 외에도, 가상 메모리 기법을 사용하면서 얻을 수 있는 이점이 많이 있습니다.가상 메모리를 사용하게 되면 프로세스 간 공간 분리를 하게 되는데 이를 통해 프로세스 간 메모리 영역 침범 이슈를 방지할 수 있고 보조 기억장치를 활용하면서 메모리 용량 부족에 대한 이슈도 해결할 수 있습니다. 가상 메모리 기법을 사용하게 되면 CPU는 메모리의 실제 주소인 Physical address대신 Virtual address에 먼저 접근하게 됩니다. 이때 페이지 테이블을 참조하여 Virtual address를 Physical address로 변환하여 실제 메모리에 접근하게 되는데 이러한 변환 과정이 굉장히 빈번하게 일어나고 속도가 굉장히 중요하므로 MMU라는 하드웨어 칩의 지원을 받습니다.MMU(Memory Management Unit)란? MMU는 Memory Management Unit으로 CPU가 코드를 실행하며 가상 메모리 주소에 접근할 때 해당 가상 메모리 주소를 실제 물리적인 주소로 변환해주는 하드웨어 장치입니다.Page란? 가상 메모리 기법을 사용할 때 어느정도의 크기씩 실제 메모리에 올려놓을 지 고민하게 되는데, 이때 기본 단위가 되는 것이 페이지입니다. 페이지 단위로 관리하게 되며 페이지 번호를 바탕으로 가상 메모리 주소와 실제 메모리 주소를 매핑하여 페이지 테이블에 기록하고 관리하게 됩니다.더 구체적으로 가상 메모리 주소에 대하여 알아보면 가상 메모리 주소 v = (p, d)와 같은 pair로 이루어져 있습니다.p는 가상 메모리 페이지를 의미하며 d는 distance로 p 내 offset을 의미합니다.가상 메모리 기법의 흐름 지금까지 배운 가상 메모리 기법의 흐름을 한번 정리해보면, CPU가 명령어를 실행하던 중 가상 메모리 주소를 참조하게 되면 하드웨어 칩셋인 MMU를 거쳐서 실제 메모리에 올라가있는 페이지 테이블을 참조하여 실질적인 메모리 주소로 변환하게 되고 그 주소를 바탕으로 메모리에 접근하게 됩니다. 여기서 알 수 있듯이 메모리에 반복적으로 접근하고 데이터를 읽어오게 되는데 이러한 속도는 CPU나 레지스터 처리 속도에 비하면 굉장히 느린 속도입니다. 이 부분에서 성능 향상을 위해서 TLB라는 하드웨어를 사용하게 됩니다.TLB(Translation Lookaside Buffer)란? TLB란 Translation Lookaside Buffer의 약자로, 최근에 접근한 페이지 정보를 기록하는 하드웨어 칩셋입니다. 즉, 가상 메모리 주소가 한번 물리 주소로 변환되면 TLB에 기록하고 있다가 그다음부터는 MMU가 페이지 테이블을 참조하는 것이 아니라 TLB에서 해당하는 물리 주소를 먼저 찾게 됩니다. 이를 통해 상대적으로 속도가 느린 메모리에 접근하는 횟수를 줄여 성능 향상을 꾀할 수 있습니다.페이지 폴트(Page fault)란? 우리가 가상 메모리 주소를 통해서 실제 물리 주소를 얻고 메모리에 접근했지만 내가 원하는 페이지가 실제 메모리에 적재되어 있지 않을 수도 있습니다. 우리는 가상 메모리 기법을 쓰고 있기 때문에 일부만 실제 메모리에 올리고 나머지는 보조 기억장치에 저장하고 있기 때문이죠. 이렇게 내가 찾는 페이지가 실제 메모리에 현재 적재되어 있지 않을 때를 페이지 폴트라고 합니다. 페이지 폴트가 발생하면 보조 기억장치에서 지금 내가 필요한 페이지를 가져오게 됩니다. 보조 기억장치는 메모리보다 속도가 더 느리기 때문에 자주 참조하면 좋지 않겠죠. 따라서 페이지 폴트를 줄이기 위해서도 다양한 기법들이 사용됩니다. 가급적이면 앞으로 실행될 코드나 참조될 데이터들을 예측해서 미리 메모리에 올려놓는 것이 좋겠죠. 이러한 기법에 대해서는 추후 포스팅에서 더 자세히 알아보도록 합시다.References https://velog.io/@gndan4/OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC" }, { "title": "기술 면접_ 동기와 비동기", "url": "/posts/sync-async/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 동기, 비동기, computer science, technical interview, synchronous, asynchronous", "date": "2021-08-23 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.동기식(Synchronous) 처리란? 동기식 처리란 직렬적으로 이루어지는 처리 과정을 말합니다. 직렬적이란 작업이 순차적으로 처리되며 이전 작업이 끝나지 않으면 다음 작업이 시작되지 않음을 의미합니다. 즉 아래 그림에서 Task1과 Task1 사이에 Get Data from Server 작업이 실행중이라면 Server로 부터 Data를 모두 받고나서야 뒤 Task1이 실행된다는 것을 의미합니다.아래와 같은 코드가 동기식 처리의 예시가 될 수 있습니다.function func1() { console.log('func1'); func2(); } function func2() { console.log('func2'); func3();} function func3() { console.log('func3');}func1();비동기식(Asynchronous) 처리란? 비동기식 처리란 동기식 처리와 비교되는 개념으로 병렬적으로 이루어지는 처리 과정을 의미합니다. 병렬적이란 의미 답게 여러개의 작업이 동시에 처리될 수 있음을 뜻합니다. 일반적으로 작업 마다 처리에 소요되는 시간이 다를 것이기 때문에 동시에 시작되더라도 먼저 끝날 수도 있고 늦게 끝날 수도 있습니다. 심지어 먼저 시작되더라도 늦게 끝날 수도 있는 것이죠. 아래 코드를 통해 이해해볼까요? function func1() { console.log('func1'); func2();} function func2() { setTimeout(function() { console.log('func2'); }, 0); func3();} function func3() { console.log('func3'); } func1(); setTimeout()이 대표적인 비동기 처리 함수인데, 타이머를 0으로 설정하였음에도 불구하고 func1, func2, func3의 순서로 console에 로그가 찍히지 않습니다.왜냐하면 setTimeout()의 콜백함수는 비동기적으로 처리될 뿐만아니라 지정된 대기 시간만큼을 기다리다가 “tick” 이벤트가 발생하면 이벤트 큐로 이동하고, Call Stack이 모두 비어진 뒤에야 Call stack으로 이동하여 실행되기 때문입니다. 위 과정을 그려보면 아래와 같습니다.References https://webclub.tistory.com/605" }, { "title": "고득점 Kit_ 해시 - Level2 - 위장", "url": "/posts/camouflage/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, hash, 고득점, 위장, 해시, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-20 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 위장 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;string&gt;&gt; clothes){ int answer = 0; multimap&lt;string, string&gt; clothesMap; vector&lt;string&gt; index; for (int i = 0; i &lt; clothes.size(); i++) { clothesMap.insert(make_pair(clothes[i][1], clothes[i][0])); } for (pair&lt;string, string&gt; i : clothesMap) { if (find(index.begin(), index.end(), i.first) == index.end()) index.push_back(i.first); } if (index.size() == 30) { return 1073741823; } for (int i = 1; i &lt;= index.size(); i++) { vector&lt;int&gt; combination; for (int j = 0; j &lt; i; j++) combination.push_back(1); for (int j = 0; j &lt; index.size() - i; j++) combination.push_back(0); sort(combination.begin(), combination.end()); do { int sum = 1; for (int k = 0; k &lt; combination.size(); k++) { if (combination[k] == 1) sum *= clothesMap.count(index[k]); } answer += sum; } while (next_permutation(combination.begin(), combination.end())); } return answer;}우선, 위 알고리즘은 틀린 알고리즘입니다. 왜냐하면 시간 초과로 테스트 케이스1을 통과하지 못했거든요. 그래서 테스트 케이스1에 대한 예외처리를 억지로 해주고 정답으로 인정받은 풀이입니다. 나름 처음부터 시간 복잡도에 대한 고려를 해야겠다 생각해서 map, set을 적극 활용했는데 결국은 30종류의 옷에대한 모든 조합의 가짓수를 구할 때 시간 초과로 실패하였습니다.틀린 알고리즘이지만 그래도 배운 것이 참 많았는데요, 저번 포스팅에서 next_permutation()으로 순열을 다룬 적이 있는데 이번에는 next_permutation()으로 조합을 만들어봤습니다.next_permutation()을 활용한 Combination? 몇일 전 포스팅에서 next_permutation()을 활용해서 순열을 구현할 수 있음을 배웠습니다. 이번에는 next_permutation()을 활용해서 조합을 구현해봤는데요, 방법은 아래와 같습니다. 1. 조합 nCr에서 n의 개수에 맞게 시퀀스 컨테이너(배열 혹은 벡터 등)을 만듭니다. 앞서 만든 컨테이너에 r의 개수만큼 1로 채워주고, 0은 n-r개만큼 채워줍니다. 앞서 배운 순열과 같이 next_permutation()으로 순열을 구해줍니다. (next_permutation()을 사용하기 때문에 그 전에 반드시 오름차순 정렬이 필요합니다.) 나온 순열들을 탐색하면서 원소로 1을 가지는 곳의 index들이 조합의 경우의 수들입니다. 위 문제는 clothes가 string들로 이루어져있어서 clothes의 종류와 일대일로 매핑되는 index라는 벡터를 따로 만들어주었습니다. 그 후 index 벡터에 1차적으로 접근한 뒤에 multimap에 접근하는 방식으로 풀이하였습니다.set, map, multiset, multimap이란? 이번 문제를 풀면서 시퀀스 컨테이너와 연관 컨테이너에 대하여 자세히 공부할 수 있었습니다.vector, array처럼 단순 자료를 저장하는 용도의 컨테이너를 시퀀스 컨테이너라고 부르며, set, map, multiset, multimap과 같이 Key 혹은 Key &amp; Value 사이의 관계가 있는 컨테이너를 연관 컨테이너라고 부릅니다.set과 map의 특징부터 살펴보면, set과 map의 공통점으로 두 컨테이너 모두 대입할 때 알아서 정렬이 된 채로 들어가게됩니다. 기본적으로 오름차순으로 되어있습니다. 차이점이라고 하면 set은 Key만을 가지고 map은 Key와 Value의 쌍을 가지게 되어 있습니다. 또한 map은 map[key] = value; 혹은 map[key]; 등과 같이 대괄호를 통해서 임의의 원소에 접근할 수 있지만 set은 []를 사용할 수 없을 뿐만 아니라 *(set1.begin()+5) 등과 같이 이터레이터에 연산을해도 접근할 수 없습니다. 단지 오름차순이 출력될 수 있게 일반적인 순서를 가지는 반복자(iterator)만을 가질 뿐입니다. 그 외에 메소드들은 서로 대부분 비슷합니다. map같은 경우에 주의해야할 점으로, Key와 Value를 쌍으로 가지다 보니 pair와 같은 자료형을 사용하며 pair에 값을 넣어주기 위해서는 make_pair()메소드를 사용하여야 합니다.multi가 붙은 자료형들도 기본적인 메소드는 대부분 유사하며, 딱 하나 차이점으로는 키값의 중복을 허용합니다. 일반적인 set, map은 Key값을 중복해서 가질 수 없습니다.다른 사람의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;int solution(vector&lt;vector&lt;string&gt;&gt; clothes){ int answer = 1; unordered_map&lt;string, int&gt; attributes; for (int i = 0; i &lt; clothes.size(); i++) attributes[clothes[i][1]]++; for (auto it = attributes.begin(); it != attributes.end(); it++) answer *= (it-&gt;second + 1); answer--; return answer;}다른 사람의 풀이를 처음 봤을 때 굉장히 허탈하고 많은 생각들이 들었습니다. 알고리즘 문제를 풀기 전에 항상 생각을 충분히하고 푼다고 생각하고 있었는데, 오늘 제가 느낀 바로는 지금까지의 저는 해결할 방법이 나왔다면 바로 시도부터 하고보는 습관이 있었던 것 같습니다.그러니까, 다시 말하면 시간적이나 공간적으로 더 효율적이고 단순한 알고리즘에 대한 고민의 시간이 많이 부족했던 것이죠. 그래서 제가 항상 답은 맞아도 시간 복잡도와 같은 효율성 측면에서 편차가 심한 것 같습니다. 앞으로는 해결 방법에 명확히 나왔다고 하더라도 더 효율적이고 시간을 절약할 수 있는 알고리즘이 없는 지 조금 더 고민의 시간을 투자해볼 생각입니다.다 각설하고, 위 알고리즘을 간단히 설명하면 아래 한줄과 같습니다. (각 종류별의 옷의 가지수 + 1)을 서로서로 모두 곱합니다. 그후 1을 뺍니다.처음에 이해가 잘 안되실 수도 있는데, 생각보다 되게 간단합니다. 각 종류의 옷에대한 경우의 수 곱 연산을 활용한 방식인데 1씩 더해주는 이유는 해당 종류의 옷을 안입을 경우에 대한 처리를 해주는 것이고 나중에 전체 값에서 1을 빼주는 이유는 모든 종류의 옷을 하나도 안입은 경우의 수를 제거 해주는 것입니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;int solution(vector&lt;vector&lt;string&gt;&gt; clothes){ int answer = 1; unordered_map&lt;string, int&gt; clothesMap; for (int i = 0; i &lt; clothes.size(); i++) { clothesMap[clothes[i][1]]++; } for (pair&lt;string, int&gt; i : clothesMap) { answer *= (i.second + 1); } return --answer;}제가 최적화한 풀이도 위 알고리즘과 거의 비슷합니다. 자료구조도 C++의 해시인 unordered_map을 사용하는 것이 시간도 그렇고 여러모로 효율적이라고 판단해서 위와같이 작성해봤습니다.References https://modoocode.com/224#page-heading-2" }, { "title": "고득점 Kit_ 탐욕법 - Level2 - 조이스틱", "url": "/posts/joystick/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, greedy, 고득점, 조이스틱, 탐욕법, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-18 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 조이스틱 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int now;bool compare(pair&lt;int, int&gt; LHS, pair&lt;int, int&gt; RHS){ return LHS.second &lt; RHS.second;}void setMinLR(vector&lt;pair&lt;int, int&gt;&gt; &amp;minLR, int nameLength){ for (int i = 0; i &lt; minLR.size(); i++) { int externalDist; now &gt; minLR[i].first ? externalDist = nameLength - now + minLR[i].first : externalDist = nameLength - minLR[i].first + now; minLR[i].second = abs(minLR[i].first - now) &lt; externalDist ? abs(minLR[i].first - now) : externalDist; } sort(minLR.begin(), minLR.end(), compare);}int solution(string name){ int answer = 0; vector&lt;pair&lt;int, int&gt;&gt; minLR; //minLR.first는 수정이 필요한 name의 index, minLR.second는 좌우 최소 이동 횟수를 의미. for (int i = 0; i &lt; name.length(); i++) { if (name[i] != 'A') minLR.push_back(make_pair(i, 0)); } while (minLR.size()) { setMinLR(minLR, name.length()); answer += minLR[0].second; //가장 짧게갈 수 있는 알파벳으로 커서 이동 answer += name[minLR[0].first] - 65 &lt; 91 - name[minLR[0].first] ? name[minLR[0].first] - 65 : 91 - name[minLR[0].first]; //가장 짧게갈 수 있는 방향을 통해 알파벳 변경 now = minLR[0].first; minLR.erase(minLR.begin()); } return answer;}조이스틱 문제도 그렇고 탐욕법 유형의 문제가 다소 악명 높다고 들어서 걱정을 많이 했었는데, 정말 뿌듯하게도 생각보다 조이스틱 문제는 어렵지 않게 풀 수 있었습니다. 하지만, 탐욕법이라는 문제 유형을 보지 못했다면 그리디적 접근을 하기까지 오랜 시간이 걸렸을 것 같습니다.그리디와 관련해서 많은 것을 알고 있지는 않지만, 저는 그때그때 주어진 컨디션에서 최적의 경로 및 경우를 탐색하고 그때그때 갈 수 있는 최적의 경우의 수를 선택하는 것이라고 이해하고 있기 때문에 solution()함수 내에서 while()루프를 돌 때마다 setMinLR()을 통해서 최적의 경우의 수를 찾는 과정을 거치도록 구현하였습니다.우선 저는 vector 컨테이너 안에 pair type을 두어 minLR이라는 변수를 적극적으로 활용하고 있습니다. 이 변수에는 pair&lt;int, int&gt;의 타입이 들어있는데 pair.first에는 초기값인 ‘A’와 달라서 수정이 필요한 name의 index number를 담도록 하였고 pair.second에는 해당 변수까지 좌우로 최소한 이동해야하는 횟수를 담고 있습니다. 상하로 이동하는 것은 어차피 나중에 한꺼번에 해줘도 되기 때문에 이 문제에서 사실 크게 중요한 포인트는 아닙니다.이 문제는 좌우의 최소 횟수를 찾는 것이 중요한데, 전 앞서 말씀드린 것처럼 그리디하게 그때 그때 주어진 컨디션에서 최적의 경로로 찾아가도록 구현하였습니다. 그리디하다라는 것과 관련해서 할말이 참 많은데 사실 제가 찾은 경로는 반례가 존재합니다. 즉 최적이 아닐 수 있습니다.제 그리디 알고리즘은, 현재 조이스틱의 커서가 위치한 곳을 기준으로 가장 빨리 도달할 수 있는 name의 수정이 필요한 인덱스로 찾아갑니다. 하지만 이것이 최적의 해를 보장하지 않는 것입니다.밑에서 나오는 다른 사람의 풀이는 조금 더 완전탐색과 같은 그리디 알고리즘을 택하여서 실제로 최적의 해를 찾아냅니다. 하지만 현재 프로그래머스에서는 테스트 케이스가 부족한 탓인지 제 알고리즘도 정답으로 인정하고 있으며, 위와 같은 문제는 지속적으로 건의가 들어가고 있는 것으로 알고 있지만 문제가 출제된지 몇년이 지나도 아직 수정되고 있지 않는 상황입니다.이렇다는 배경 이야기가 있다는 점은 이제 그만 각설하고 제 알고리즘에 대하여 조금 살펴볼까 합니다.제 알고리즘은 그렇게 이해하기 어렵지는 않습니다. setMinLR() 메소드가 좀 중요한 로직인데요, 내부에 externalDist라는 변수를 두어서 outer cycle(외선 순환)으로 이동하는 경우와 inner cycle(내선 순환)으로 이동하는 경우를 나누었고, ExternalDist는 outer cycle을 의미합니다.그후 내선 순환과 외선 순환의 길이를 비교하여 minimum값을 minLR[i].second에 저장하는 방식입니다. 이걸 solution()에서 while loop가 돌 때마다 주기적으로 해주면서 minLR값을 그때그때 최적화 시키는 것이죠.하지만 위에서 언급했듯이 이건 최적해가 아닙니다. 제가 오랜 시간 고민해본 결과 그 이유는 바로, 제 알고리즘은 현재 커서가 위치한 기준에서 최적의 경우를 탐색하기 때문입니다. 다른 사람의 최적 풀이를 보면 그 풀이는 현재 커서를 현재 그 위치가 아닌 다른 위치, 모든 인덱스로 이동시켜서 그때도 최적의 경우를 탐색합니다. 조금 더 완전 탐색과 같은 방법인 셈입니다. 이렇게 하여야 우리가 원하는 진정 최적의 해를 구할 수 있습니다.다른 사람의 풀이를 넘어가기 전에 제 알고리즘에서 쓰였던 pair에 대해서 알아보고 넘어갑시다.pair&lt;[Type], [Type]&gt;란? pair&lt;[Type], [Type]&gt;이란 두개의 서로 다른 혹은 같은 타입을 연관지어 하나의 타입으로 저장하는 방식을 말합니다. 연관된 2개의 값에서 각각의 조건에 따라 정렬된 결과를 얻을 수도 있고 서로 다른 타입을 연관지을 수 있다는 점에서 요긴하게 사용됩니다. pair&lt; int, int&gt; test = make_pair(1, 2);vector&lt;pair&lt;int, int&gt;&gt; minLR; 위와 같이 선언하여 사용할 수 있으며, make_pair()를 통해 pair에 데이터를 넣어줄 수 있습니다.다른 사람의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int LUT[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};int solution(string name){ int answer = 0; for (auto ch : name) answer += LUT[ch - 'A']; int len = name.length(); int left_right = len - 1; for (int i = 0; i &lt; len; ++i) { int next_i = i + 1; while (next_i &lt; len &amp;&amp; name[next_i] == 'A') next_i++; left_right = min(left_right, i + len - next_i + min(i, len - next_i)); } answer += left_right; return answer;}앞서서 거두절미하게 얘기했던 정말 최적해를 구하는 알고리즘이며, 엄청 효율적으로 짜여진 알고리즘입니다. 처음에는 이해하기도 굉장히 어려웠습니다.우선 위 알고리즘을 한줄로 표현하면 상하로 움직이는 이동 횟수는 LUT[]라는 배열을 통해 미리 다 계산을 해놓고 간소화시켰고 좌우로 이동하는 최소 횟수가 핵심이 되는데요, 그 과정은 아래 for문에서 모두 이루어집니다. for (int i = 0; i &lt; len; ++i) { int next_i = i + 1; while (next_i &lt; len &amp;&amp; name[next_i] == 'A') next_i++; left_right = min(left_right, i + len - next_i + min(i, len - next_i)); }이게 완전 탐색에 가까운 그리디 방식이라고 불렀던 부분입니다. 제 풀이와 다른 점이 느껴지시나요?저는 현재 커서가 위치한 곳을 기준으로 최적의 경우의 수를 따졌다면 이 풀이에서는 for문을 통해서 커서를 이동할 수 있는 범위 내에서 모두 이동시켜보고 그때그때 left_right에 최적의 경우를 저장해가면서 탐색합니다.여기서 left_right에 minimum값을 넣는 로직이 이해하기가 굉장히 어려울 수 있습니다.이 부분에 대하여 조금 설명을 하자면, i는 커서의 위치입니다. 예를들어서 문제 조건상 실제로는 커서가 index 0번에 있지만 이걸 for문의 ++i를 통해서 1번,2번,3번… 등과 같은 다른 인덱스에도 이동을 시켜봅니다. 이동을 시켜본 뒤에 그 위치에서 name에서 수정이 필요한 Index를 모두 이동할 때 드는 최소 경로 비용을 계산해보는 것이죠.우선 min()안에 left_right의 초기값은 len-1입니다. 이건 좌우 왼쪽으로 움직이지 않고 index 0부터 index len-1까지 한 방향으로 움직이는 경우를 말합니다. 이게 사실상 좌우를 움직이는 최대값이 되겠죠. 그렇다면 i+len - next_i + min(i, len - next_i)가 좌우를 왔다갔다 방향을 바꿔가며 이동했을 때 최적의 경로가 될텐데 이 상황은 이렇게 이해하면 쉽습니다.현재 커서가 index i번째에 있다고 치고, 커서 기준으로 우측에 가장 가까이 있는 수정이 필요한 index를 찾습니다. 그게 next_i입니다. 그러면 i와 next_i 사이에는 수정이 필요한 알파벳이 없다는 것은 확실해졌습니다. 그 말인 즉슨 i와 next_i의 outer cycle에는 수정이 필요한 알파벳이 존재할 수도 있으므로 모두 탐색해봐야한다는 말입니다. 즉 i와 next_i의 outer cycle에대한 경로가 반드시 탐색되어야하는 것이죠.그 길이가 i + len - next_i + min(i, len - next_i)입니다.이 부분만 이해한다면 조이스틱의 최적해가 어떻게 나오는지 감이 다 잡히신 것입니다.최적화한 나의 풀이최적화한 풀이가 다른 사람의 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.References https://godog.tistory.com/entry/c-vector-and-pair-%EC%82%AC%EC%9A%A9" }, { "title": "고득점 Kit_ 완전탐색 - Level2 - 소수 찾기", "url": "/posts/find-prime-numbers/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, exhaustive search, 고득점, 소수 찾기, 완전탐색, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-16 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 소수 찾기 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;set&lt;string&gt; result;void recursive(vector&lt;string&gt; temp, string i, string num){ if (i != \"0\" || num.length() != 0) { num += i; result.insert(num); } temp.erase(find(temp.begin(), temp.end(), i)); for (string i : temp) recursive(temp, i, num);}bool isPrimeNumber(string num){ int number = stoi(num); if (number &lt;= 1) return false; for (int i = 2; i &lt; number; i++) { if (number % i == 0) return false; } return true;}int solution(string numbers){ int answer = 0; vector&lt;string&gt; nums; for (char i : numbers) { nums.push_back(to_string(i - 48)); } for (string i : nums) recursive(nums, i, \"\"); for (string i : result) { if (isPrimeNumber(i)) answer++; } return answer;}문제에 주어진 조건에 따르면 numbers는 길이가 7이하인 문자열이기 때문에 최대 7자리의 정수가 나오게 됩니다. 이 정수로 만들어질 수 있는 모든 숫자들을 구하는 로직이 관건이 될텐데 처음에 저는 중첩 for문을 통해서 해결하려고 했으나 상당한 깊이의 중첩구조가 나오게 된다는 것을 깨닫고 재귀 함수를 이용하여 구현하도록 하였습니다.그래서 제 알고리즘의 핵심인 recursive 재귀함수 먼저 살펴보도록 하겠습니다. if (i != \"0\" || num.length() != 0) { num += i; result.insert(num); }우선 위 코드와 같은 경우에는 맨 앞에 0이 오는 경우를 걸러주는 것입니다. 즉, 0으로 시작하는 숫자가 만들어질 수 없도록 구현하였습니다. 미리 말씀드리자면 numbers 속 숫자들을 통해 만들어질 수 있는 숫자는 result라는 set 자료구조에 저장되도록 구현하였습니다. set을 사용했기 때문에 중복된 key값은 알아서 제거되며, 디폴트로 오름차순으로 정렬됩니다. set에 대해서 간단히 알아볼까요?set이란? set은 set, multiset, map, multimap을 포함하는 연관 컨테이너(associate container) 중 하나입니다. 연관 컨테이너란 key와 value처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너입니다. 그 중에서도 set은 가장 단순한 연관 컨테이너로, value를 key값 그 자체로 사용합니다. 또한 set에서는 key 값의 중복을 허용하지 않고, multiset은 key 값의 중복을 허용한다는 점에서 차이점을 가지고 있습니다. set&lt;int&gt; s1; 위와 같이 선언하여 사용하며, set에서는 기본적으로 오름차순에 맞게 정렬하여 데이터를 삽입합니다.다시 돌아와서, recursive 함수에 대해서 조금 더 살펴보겠습니다. recursive에는 총 3개의 매개변수를 넘겨받습니다. temp에는 재귀 함수를 호출할 때마다 사용할 수 있는 numbers 내의 숫자들을 vector로 담고 있고, i에는 이번에 사용할 number를 지칭합니다. num에는 지금까지 numbers 내의 일부 숫자들을 이용해 구현된 부분 문자열을 담고 있습니다.따라서, i를 통해 이번에 사용할 number를 넘겨받고 i를 추가한 num을 result에 넣어줍니다. 그 후 사용한 i는 temp에서 제거해주는 로직입니다.solution내에 사용한 로직을 설명하자면, nums라는 string vector를 두었고 numbers 내의 각각의 문자를 아스키 코드와 to_string을 활용해서 하나하나의 string으로 변환하여 nums vector 내부에 삽입하였고 이 배열을 매개로 재귀 함수를 호출하여 문제를 해결하였습니다.다른 사람의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define MAX 9999999999using namespace std;bool isPrime(int number){ if (number == 1) return false; if (number == 2) return true; if (number % 2 == 0) return false; bool isPrime = true; for (int i = 2; i &lt;= sqrt(number); i++) { if (number % i == 0) return false; } return isPrime;}bool compare(char a, char b){ return a &gt; b;}int solution(string numbers){ int answer = 0; string temp; temp = numbers; sort(temp.begin(), temp.end(), compare); vector&lt;bool&gt; prime(std::stoi(temp) + 1); //cout &lt;&lt; stoi(temp) &lt;&lt; endl; prime[0] = false; for (long long i = 1; i &lt; prime.size(); i++) { prime[i] = isPrime(i); } //cout &lt;&lt; \"chk1\" &lt;&lt; endl; //int num = std::stoi(numbers); string s, sub; s = numbers; sort(s.begin(), s.end()); set&lt;int&gt; primes; int l = s.size(); do { for (int i = 1; i &lt;= l; i++) { sub = s.substr(0, i); // cout &lt;&lt; \"chk2\" &lt;&lt; \" \" &lt;&lt; sub&lt;&lt; endl; if (prime[std::stoi(sub)]) { primes.insert(std::stoi(sub)); } } } while (next_permutation(s.begin(), s.end())); //cout &lt;&lt; primes.size(); answer = primes.size(); return answer;}해당 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 엄청난 추천수를 받았는데 평소와는 느낀 점이 조금 다릅니다. 우선 해당 알고리즘에서 핵심은 next_permutation()이라는 C++ algorithm 라이브러리 내에 순열 메소드를 사용했다는 점입니다만, 그 외에 코드는 썩 효율적이지 못한 부분도 존재한다고 생각합니다. 우선 next_permutation()이 무엇인지 알아보겠습니다.next_permutation()이란? next_permutation()은 C++ algorithm 내에 존재하는 순열 기능을 제공하는 메소드입니다. 기본적으로 next_permutation()은 인자로 iterator를 받기 때문에 vector 뿐만 아니라 string 타입 변수의 순열도 구해낼 수 있습니다. 이 메소드는 더 큰 순열로 재배열할 수 있으면 반복하여 구해내는 로직을 가지고 있어서 앞에 이미 큰 원소들이 배치되어 있으면 모든 순열의 경우의 수를 구할 수 없습니다. 즉, 오름차순으로 정렬되어있는 상태에서 next_permutation()을 사용해야 모든 경우의 수를 구할 수 있습니다. string s = \"1234\";do {\tcout &lt;&lt; s &lt;&lt; \" \";} while (next_permutation(s.begin(), s.end())); 위와 같이 사용하면 1,2,3,4를 활용한 모든 순열이 출력되게 됩니다.다시 위 알고리즘으로 돌아와서 간략한 로직을 설명하자면, isPrime()은 이름에서 유추할 수 있듯이 소수인지 확인해주는 메소드입니다. 이 내부에서는 sqrt()를 활용해서 조금 더 효율적으로 소수를 찾을 수 있도록 구현하였습니다.solution() 부분을 보면 다소 이해하기 어려울 수 있는데 각각의 변수 및 로직에 대하여 간략히 설명하자면 **prime이라는 vector이 있는데 이 벡터에는 0부터 numbers로 만들 수 있는 최대의 숫자까지 인덱스를 가지게 구현되어 있고 각각의 인덱스에 해당하는 값은 해당 인덱스가 소수인지 아닌지에 따라서 bool 값을 가지게 구현**되어 있습니다. 즉 prime[3]을 예로들면 3은 소수이기 때문에 true라는 값을 가지고 있습니다. 간단히 말해서 **numbers로 만들 수 있는 숫자 범위 내의 모든 숫자에 대한 소수 여부 체크를 미리 해놓고 담아놓은 변수**라고 생각하시면 될 것 같습니다.그렇다면 추후에 이 벡터의 인덱스에 접근해서 소수 여부를 체크하기 쉽겠죠?s라는 string은 numbers 값을 가지고 있고 오름차순으로 정렬합니다. 왜냐하면next_permutation()을 활용하기 위해서 오름차순으로 정렬해놓은 것이죠. 이렇게 구해진 모든 순열의 경우의 수에서 구할 수 있는 모든 부분 문자열을 구하고 해당 부분 문자열을 int형으로 바꿔서 아까 미리 소수를 체크해놓은 prime 벡터에 인덱스로 접근하여 소수 여부를 체크합니다. 소수가 맞다면 primes라는 set 자료 구조에 해당 값을 넣어 소수의 개수를 카운팅하는 방식으로 이루어져있습니다. 제 알고리즘과 다른 큰 차이점이라면 순열의 경우의 수를 구하기 위해서 저는 재귀 함수를 활용했다면 위 알고리즘은 next_permutation() 메소드를 활용했다고 볼 수 있겠네요.최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.References https://notepad96.tistory.com/entry/C-%EC%88%9C%EC%97%B4Permutation-nextpermutationhttps://blockdmask.tistory.com/79" }, { "title": "고득점 Kit_ 정렬 - Level2 - 가장 큰 수", "url": "/posts/the-greatest-number/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, sort, 고득점, 가장 큰 수, 정렬, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-15 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 가장 큰 수 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compare(string lhs, string rhs){ return lhs + rhs &gt; rhs + lhs;}string solution(vector&lt;int&gt; numbers){ string answer = \"\"; int count = 0; vector&lt;string&gt; nums; for (int i : numbers) nums.push_back(to_string(i)); sort(nums.begin(), nums.end(), compare); for (string i : nums) { answer += i; if (i == \"0\") count++; } if (count == nums.size()) return answer = \"0\"; return answer;}우선 위 풀이는 저 혼자만의 힘으로 푼 알고리즘이 아닙니다. 구조적인 부분은 굉장히 비슷하였지만 compare 함수 구현 중에 도저히 또다른 반례를 찾을 수 없어서 질문을 올리는 게시판에 들어가서 반례를 찾다가 compare 구현 아이디어를 스포 당했습니다.저는 이중 If문 등을 활용하여 현재 Compare와 비슷한 로직을 가지는 구조를 구현하고 계속 시도하였지만 테스트 케이스 1~6번에서 계속 막혔었습니다. 그 중 위와같이 매우 간단한 문장으로 제가 생각했던 구조를 구현할 수 있어서 위 방법을 택했습니다.그 외에 Solution 함수 부분에서 int를 모두 string으로 바꾸는 작업을 해주기 위해 string 라이브러리 내에 있는 to_string() 메소드를 활용하였습니다.to_string()이란? 메소드 명에서 유추할 수 있듯이 string type으로 바꿔주는 함수입니다. C++ string 라이브러리 내에 존재하며, to_string(123); 위와 같이 사용하면 됩니다.less&lt;&gt;, greater&lt;&gt;란? 오늘은 sort()와 아래와 같이 함께 쓰이는 less&lt;&gt;, greater&lt;&gt; 임시 객체에 대해 알아보겠습니다. sort(v.begin(), v.end(), less&lt;int&gt;);sort(v.begin(), v.end(), greater&lt;int&gt;); 위 이름에서 어느정도 유추할 수 있듯이, (왼쪽 매개변수 기준)less는 더 작은, greater는 더 크다는 의미를 가집니다. 즉 less는 오름차순을 의미하고 greater는 내림차순을 의미합니다.C++ 버전에 따라 less나 greater 뒤에 자료형 명시를 안해줘도 되는 경우도 있긴하나 낮은 버전에서는 타입 추론이 안되기 때문에 가급적이면 명시를 해주는 것이 좋겠습니다.다른 사람의 풀이#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;bool compare(const string &amp;a, const string &amp;b){ if (b + a &lt; a + b) return true; return false;}string solution(vector&lt;int&gt; numbers){ string answer = \"\"; vector&lt;string&gt; strings; for (int i : numbers) strings.push_back(to_string(i)); sort(strings.begin(), strings.end(), compare); for (auto iter = strings.begin(); iter &lt; strings.end(); ++iter) answer += *iter; if (answer[0] == '0') answer = \"0\"; return answer;}해당 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 저와 풀이가 대부분 동일하며 하나 차이가 있다면, [0, 0, 0] =&gt; “0” 과 같은 테스트 케이스를 예외처리를 해주는 부분에서 저보다 간결하며 효율적입니다. 저는 제 알고리즘에서 Count라는 변수를 두어 처리를 해줬다면, 위 알고리즘에서는 이미 정렬되어있음을 그대로 이용하여 answer[0]을 통해 위 케이스를 걸러주었습니다.compare 함수와 같은 경우에는 로직이 동일하지만 코드 가독성 측면에서 제 코드가 더 깔끔하다고 생각합니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compare(string lhs, string rhs){ return lhs + rhs &gt; rhs + lhs;}string solution(vector&lt;int&gt; numbers){ string answer = \"\"; vector&lt;string&gt; nums; for (int i : numbers) nums.push_back(to_string(i)); sort(nums.begin(), nums.end(), compare); for (string i : nums) { answer += i; } if (answer[0] == '0') //이 부분이 최적화한 코드 answer = \"0\"; return answer;}많은 추천을 받은 효율적인 알고리즘이 제 로직과 별로 다를 것이 없어서, 바로 위에서 언급했던 예외 케이스에 대한 부분만 조금 더 효율적으로 가다듬어 봤습니다.References https://blockdmask.tistory.com/334https://itguava.tistory.com/67" }, { "title": "고득점 Kit_ 스택/큐 - Level2 - 프린터", "url": "/posts/printer/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, stack, queue, 고득점, 프린터, 스택, 큐, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-13 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 프린터 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; priorities, int location){ int answer, count = 0; vector&lt;int&gt; index; for (int i = 0; i &lt; priorities.size(); i++) index.push_back(i); while (priorities.size() != 0) { int tempPriority = priorities[0]; int tempIndex = index[0]; priorities.erase(priorities.begin()); index.erase(index.begin()); if (tempPriority &lt; *max_element(priorities.begin(), priorities.end())) { priorities.push_back(tempPriority); index.push_back(tempIndex); } else { count++; if (tempIndex == location) return answer = count; } }}제가 생각했을 때 위 문제 풀이의 핵심은 처음의 인덱스 넘버가 각 문서의 이름과 같은 역할을 하지만, 인덱스의 특징과는 다르게 한번 정해진 인덱스가 우선 순위에 따라 순서가 뒤바뀌면서 인덱스로서 역할을 하지 못한다는 것입니다.즉 쉽게 말하면, 각 문서의 이름과 prioritiy를 마치 pair처럼 잘 엮어줘야한다는 것이죠.그래서 저는 index를 마치 문서의 이름처럼 사용하기로 정하고, vector&lt;int&gt; index를 선언해줬습니다. 그리고 난 뒤 문제 내 로직에 따라 priorities의 순서가 바뀌면 그와 동일하게 index또한 순서가 바뀌도록 구현하여 각 priority에 올바른 문서 이름(index)이 매칭될 수 있도록 설계하였습니다.max_element()란? priorities 내에서 우선 순위 최고값과 비교하기 위해 저는 max_element()라는 메소드를 사용하였습니다.max_element란 C++ algorithm 라이브러리에 있는 메소드입니다. 최대값이 위치한 위치를 리턴해주게 되어있습니다. \t*max_element(v.begin(), v.end()); 위처럼 사용하게 되면 v라는 vector의 최대값이 반환되는 형식입니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; priorities, int location){ queue&lt;int&gt; printer; //queue에 index 삽입. vector&lt;int&gt; sorted; //정렬된 결과 저장용 for (int i = 0; i &lt; priorities.size(); i++) { printer.push(i); } while (!printer.empty()) { int now_index = printer.front(); printer.pop(); if (priorities[now_index] != *max_element(priorities.begin(), priorities.end())) { //아닌경우 push printer.push(now_index); } else { //맞는경우 sorted.push_back(now_index); priorities[now_index] = 0; } } for (int i = 0; i &lt; sorted.size(); i++) { if (sorted[i] == location) return i + 1; }}해당 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 저와 풀이가 대부분 동일하지만 특징적인 차이점은 제가 선언한 index라는 vector대신 printer라는 queue를 사용했다는 점과, sorted라는 벡터를 통해 출력되는 순서를 관리하며, 출력된 priority 원소 같은 경우에 저는 erase를 사용해서 실질적으로 해당 자료에서 삭제해줬지만, 위 알고리즘은 0으로 바꿔 사용하였습니다.다른 사람의 풀이2#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; priorities, int location){ int answer = 0; int max = *max_element(priorities.begin(), priorities.end()); while (true) { for (int i = 0; i &lt; priorities.size(); ++i) { if (priorities[i] == max) { ++answer; if (i == location) return answer; priorities[i] = 0; max = *max_element(priorities.begin(), priorities.end()); } } }}위 알고리즘은 굉장히 간결하면서 기발한 알고리즘이라고 생각합니다. 우선 이 알고리즘의 핵심은 priorities 벡터 인덱스에 변형을 가하지 않아서 따로 제 알고리즘의 Index와 같은 벡터를 둘 필요가 전혀 없습니다. 그러면서 문제 조건에도 잘 부합하는 것이 while문 안에 for문이 index 순서에 걸맞게 돌면서, priorities[i]가 0으로 설정되면(i번째 문서가 출력되면) max값을 다시 재설정해주면서 문제에서 원하는 흐름에 잘 부합하기도 합니다. 여러모로 많은 고민이 녹아있는 알고리즘이라고 생각되어 개인적으로 가장 마음에 드는 알고리즘입니다.다른 사람의 풀이3#include &lt;string&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; priorities, int location){ int answer = 0; queue&lt;pair&lt;int, int&gt;&gt; q; priority_queue&lt;int&gt; pq; for (int i = 0; i &lt; priorities.size(); i++) { pq.push(priorities[i]); q.push(make_pair(i, priorities[i])); } pair&lt;int, int&gt; tmp; while (!q.empty()) { if (q.front().second == pq.top() &amp;&amp; q.front().first == location) { break; } else if (q.front().second == pq.top()) { q.pop(); pq.pop(); answer++; } else { tmp = q.front(); q.pop(); q.push(tmp); } } return answer + 1;}본 풀이는 스택/큐 유형에 걸맞게 우선순위 큐를 활용하여 풀이한 알고리즘입니다. 제 알고리즘을 풀이한 부분에서도 언급했듯이 이 문제에서는 프린트할 문서의 이름과 해당 문서의 우선순위를 잘 매핑시켜주는 것이 중요합니다. 위 풀이에서는 q라는 queue를 두었고, 내부적으로 pair를 활용해서 문서의 이름과 해당 문서의 우선순위를 매핑해줬음을 확인할 수 있습니다.그리고 우선순위 큐를 활용하여 우선순위에 대한 연산은 따로 구분해주었습니다.최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다." }, { "title": "고득점 Kit_ 탐욕법 - Level1 - 체육복", "url": "/posts/workout-clothes/", "categories": "Computer science, Algorithm", "tags": "level1, programmers, greedy, 고득점, 체육복, 탐욕법, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 체육복 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int solution(int n, vector&lt;int&gt; lost, vector&lt;int&gt; reserve){ int answer = 0; sort(lost.begin(), lost.end()); //lower_bound를 사용하기 위한 정렬 for (int i = 0; i &lt; reserve.size(); i++) { //여벌 체육복 있는 친구가 도난 당했을 경우에 대한 전처리 vector&lt;int&gt;::iterator ptr1 = lower_bound(lost.begin(), lost.end(), reserve[i]); if (ptr1 != lost.end()) { //lower_bound로 적절한 값을 찾지 못할 경우 .end()가 반환되므로 런타임 에러 발생 방지를 위하여 예외처리 if (reserve[i] == *ptr1) { reserve.erase(reserve.begin() + i); lost.erase(ptr1); i--; } } } for (int i = 0; i &lt; reserve.size(); i++) { vector&lt;int&gt;::iterator ptr2 = lower_bound(lost.begin(), lost.end(), (reserve[i] - 1)); if (ptr2 != lost.end()) { if ((reserve[i] - 1) == *ptr2) { reserve.erase(reserve.begin() + i); lost.erase(ptr2); i--; continue; } } vector&lt;int&gt;::iterator ptr3 = lower_bound(lost.begin(), lost.end(), (reserve[i] + 1)); if (ptr3 != lost.end()) { if ((reserve[i] + 1) == *ptr3) { reserve.erase(reserve.begin() + i); lost.erase(ptr3); i--; } } } answer = n - lost.size(); return answer;}본 문제에도 잘 나와있지만, 여벌 체육복을 가지고 있지만 해당 학생이 도난을 당한 경우가 있을 수도 있습니다. 따라서 저는 그 부분에 집중하여 가장 먼저 해당 이슈에 대한 전처리를 진행하였습니다.위 전처리를 위해서 사용된 메소드가 lower_bound()입니다.lower_bound(), upper_bound()란? lower_bound()는 C++ algorithm 라이브러리에 존재하는 메소드로 유사한 기능의 메소드로는 upper_bound()가 있습니다. lower_bound()는 내부적으로 이진 탐색을 통해 찾으려는 key값과 같거나 더 큰 값이 몇 번째 인덱스에서 처음 존재하는지 반환해주는 메소드입니다.내부적으로 이진 탐색을 활용하기 때문에 탐색 대상이 되는 자료는 정렬이 되어있는 상태여야 합니다. template &lt;class ForwardIt, class T&gt;ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value);ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value); lower_bound()와 upper_bound()는 위와 같은 원형을 가집니다.이터레이터를 활용한 범위를 가지는 다른 대부분의 메소드와 마찬가지로 [first, last)의 범위를 가진다는 점에 주의하여야 합니다.또한, lower_bound()와 upper_bound()모두 원하는 키 값을 해당 범위에서 찾지 못할 경우에 last에 해당하는 iterator가 반환됩니다.이렇게 전처리를 해주고 난 뒤에 본격적으로 lost에서 reserve[i]의 전 후에 있는 학생들에게 체육복을 빌려줍니다. 우선적으로 reserve[i]의 앞에 있는 학생들의 체육복을 빌려주도록 설계하였습니다. 왜냐하면, 예를들어 3번의 학생은 앞에있는 학생인 2번의 학생에게 빌려주고 6번 학생은 뒤에있는 7번 학생에게 빌려준다는 등 이런 식으로 앞 뒤 혼용하여 빌려주게 되면, 최대한 많은 학생에게 빌려주기 위한 최적의 알고리즘이 나오지 않기 때문입니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int student[35];int solution(int n, vector&lt;int&gt; lost, vector&lt;int&gt; reserve){ int answer = 0; for (int i : reserve) student[i] += 1; for (int i : lost) student[i] += -1; for (int i = 1; i &lt;= n; i++) { if (student[i] == -1) { if (student[i - 1] == 1) student[i - 1] = student[i] = 0; else if (student[i + 1] == 1) student[i] = student[i + 1] = 0; } } for (int i = 1; i &lt;= n; i++) if (student[i] != -1) answer++; return answer;}프로그래머스에서 가장 많은 추천수를 받은 풀이 방법입니다. 제 풀이 방법과 많이 다른데요, 저와 같은 경우에는 lower_bound()라는 메소드를 이번에 처음 알게되어서 공부하자는 의미로 대부분에 로직에서 lower_bound()를 사용했었습니다.위 알고리즘의 큰 특징은 넉넉한 크기의 student라는 전역 배열을 활용하여 해당 배열에 각 학생별로 가지고 있는 체육복의 개수를 카운팅했다는 점입니다. 제 풀이방법과 관점이 조금 다른 것이죠.여기서 가장 많이들 헷갈려하고 중요한 문법이 있습니다.for(int i: vector&lt;int&gt; v)란? 아래 코드에 집중해봅시다. 저도 이번 풀이 방법을 보면서 처음 알게된 문법인데요, for (int i : reserve) student[i] += 1; 위 코드를 조금 더 이해하기 쉽게 바꾸면 아래와 같습니다. for (int i=0; i&lt;reserve.size(); i++) student[reserve[i]] += 1; 여기서 주의해야할 것은 student 배열에 인덱스로 접근할 때 for문의 제어 변수인 i로 접근하는 것이 아니고 reserve[i] 값으로 접근한다는 점입니다. 문제속 reserve[i]에는 1보다 큰 값만이 들어있기 때문에 하단 부 for문의 제어변수 역시 1부터 순회하도록 한 것이지요.최적화한 나의 풀이#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int student[35];int solution(int n, vector&lt;int&gt; lost, vector&lt;int&gt; reserve){ int answer = 0; for (int i = 0; i &lt; reserve.size(); i++) student[reserve[i]]++; for (int i = 0; i &lt; lost.size(); i++) student[lost[i]]--; for (int i = 1; i &lt;= n; i++) { if (student[i] == -1) { if (student[i - 1] == 1) student[i - 1] = student[i] = 0; else if (student[i + 1] == 1) student[i] = student[i + 1] = 0; } } for (int i = 1; i &lt;= n; i++) if (student[i] != -1) answer++; return answer;}최적화한 풀이는 “다른 사람의 풀이1”과 동일하여 자세한 설명은 이하 생략합니다." }, { "title": "고득점 Kit_ 깊이/너비 우선 탐색(DFS/BFS) - Level2 - 타겟 넘버", "url": "/posts/target-number/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, BFS, DFS, 고득점, 타겟 넘버, 깊이/너비 우선 탐색, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 타겟 넘버 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;void PlusOrMinus(vector&lt;int&gt; numbers, int temp, int i, int target, int *answer){ if (i == numbers.size()) return; int temp1 = temp + numbers[i]; int temp2 = temp - numbers[i]; if (i == numbers.size() - 1 &amp;&amp; temp1 == target) ++(*answer); if (i == numbers.size() - 1 &amp;&amp; temp2 == target) ++(*answer); PlusOrMinus(numbers, temp1, i + 1, target, answer); PlusOrMinus(numbers, temp2, i + 1, target, answer);}int solution(vector&lt;int&gt; numbers, int target){ int answer = 0; PlusOrMinus(numbers, numbers[0], 1, target, &amp;answer); PlusOrMinus(numbers, -numbers[0], 1, target, &amp;answer); return answer;}우선, 문제를 잘 이해해야 합니다. numbers라는 매개 변수로 숫자들이 넘어오게되는데 우리는 이 각각의 숫자 앞에 + 혹은 -를 붙여서 계산해야하고 그 값이 target의 값과 일치하는 가짓수를 찾는 문제입니다.저는 PlusOrMinus라는 재귀 함수를 두어서 이 문제를 풀었습니다. 이 재귀 함수 구조는 이진 트리로 생각할 수 있는데요, 재귀함수가 호출되면 temp라는 노드의 값을 넘겨받고 그 temp 값에서 +와 -가지로 뻗어나가는 방식입니다. +쪽으로 뻗어나가면 temp1이라는 노드가 생기고, -쪽으로 뻗어나가면 temp2라는 노드가 생기도록 구현한 것입니다.그리고 PlusOrMinus라는 재귀 함수의 매개 변수 중에서 int i를 활용하여 재귀 함수의 호출이 언제 중단되어야 하는지 종단점을 설정해주었습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; numbers, int target){ int answer = 0; int size = 1 &lt;&lt; numbers.size(); //비트 마스킹을 활용한 풀이이다. 다 적어보니 이해가 되었다. for (int i = 1; i &lt; size; i++) { int temp = 0; for (int j = 0; j &lt; numbers.size(); j++) { if (i &amp; (1 &lt;&lt; j)) { temp -= numbers[j]; } else temp += numbers[j]; } if (temp == target) answer++; } return answer;}위 코드는 저에게 상당히 신성한 충격을 주었습니다. 비트 마스킹을 활용한 풀이법입니다. 저는 비트를 가지고 놀기에는 수준이 부족하여 처음엔 코드 작동 원리를 이해하기 조차 버거웠습니다. 이 코드의 반복문을 따라 하나하나 이진수를 적어가니 그제서야 동작의 흐름이 보였습니다.정말 간단히 설명하자면 비트 마스킹 기법을 활용해서 제가 위에서 재귀 함수를 통해 구현했던 그런 이진 트리 탐색의 경우의 수를 모두 구현해냈다고 생각하시면 됩니다. 하지만 위 풀이에 잘못된 점이 있습니다. 바깥 반복문에서 i=1로 초기화 되어있는데, i=0이 되어야 됩니다. i가 1부터 시작하게 되면 numbers가 1,1,1,1,1이고 target이 5일 때 정상적인 결과를 내지 못합니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int total;void DFS(vector&lt;int&gt; &amp;numbers, int &amp;target, int sum, int n) //나의 풀이와 매우 비슷하다.{ if (n &gt;= numbers.size()) { if (sum == target) total++; return; } DFS(numbers, target, sum + numbers[n], n + 1); DFS(numbers, target, sum - numbers[n], n + 1);}int solution(vector&lt;int&gt; numbers, int target){ int answer = 0; DFS(numbers, target, numbers[0], 1); DFS(numbers, target, -numbers[0], 1); answer = total; return answer;}이 풀이는 제가 푼 풀이 방식과 굉장히 비슷하지만, 저보다 효율적인 코드입니다. 어떤 부분이 효율적인지 구체적으로 말씀을 드리자면 우선, 저같은 경우에는 +와 -가지로 나뉠 때 각각의 sum을 가지는 temp변수를 temp1, temp2로 총 2개를 나누어서 선언했지만 해당 코드는 int sum이라는 변수 하나로 통일해서 가져가고 있습니다. 따라서 종단점을 설정해줄 때도 temp1, temp2에 대해서 나눠서 비교해줄 필요가 없으니 종단점을 설정해주는 if문의 길이도 짧아질 수 있었습니다.또 하나 다른 점이라면, 저는 재귀 함수를 호출하기 전에 따로 temp를 계산해주고 넣어주는 방식을 취했다면 해당 코드는 호출함과 동시에 temp를 계산해주었다는 점이 차이점이라고 할 수 있을 것 같습니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;void PlusOrMinus(vector&lt;int&gt; numbers, int temp, int i, int target, int *answer){ if (i == numbers.size()) { if (temp == target) ++(*answer); return; } PlusOrMinus(numbers, temp + numbers[i], i + 1, target, answer); PlusOrMinus(numbers, temp - numbers[i], i + 1, target, answer);}int solution(vector&lt;int&gt; numbers, int target){ int answer = 0; PlusOrMinus(numbers, numbers[0], 1, target, &amp;answer); PlusOrMinus(numbers, -numbers[0], 1, target, &amp;answer); return answer;}그래서 저는 “다른 사람의 풀이2”에서 저보다 효율적이었던 부분을 참고하여 위처럼 수정해보았습니다. 위에서 자세히 과정을 설명해 놓았으니 이하 설명은 생략합니다." }, { "title": "고득점 Kit_ 힙 - Level2 - 더 맵게", "url": "/posts/spicier/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, heap, 고득점, 더 맵게, 힙, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 더 맵게 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int solution(vector&lt;int&gt; scoville, int K){ int answer = 0; int count = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (int i = 0; i &lt; scoville.size(); i++) { pq.push(scoville[i]); } while (1) { if (pq.top() &gt;= K) { answer = count; return answer; } else { if (pq.size() == 1) { return -1; } int mix = pq.top(); pq.pop(); mix += (pq.top() * 2); pq.pop(); pq.push(mix); count++; } }}문제 유형 자체가 Heap으로 분류되는 문제인만큼, 우선순위 큐를 사용해야 한다고 생각해서 저는 priority_queue를 사용해서 문제를 풀었습니다.우선순위 큐(Priority Queue)란? 우선순위 큐는 기본적인 큐(Queue) 자료구조에 어떤 정렬 기준이 되는 우선 순위가 존재하는 큐를 말합니다. C++에서는 #include &lt;queue\\&gt; 를 해주면 사용할 수 있으며, 선언은 아래와 같이 합니다. priority_queue&lt;자료형,구현체,비교 연산자&gt; 구현체란, 우선순위 큐를 만들 때 사용할 자료구조를 뜻하며 일반적으로 Vector를 사용합니다.비교 연산자는 **우선순위를 나타내는 정렬 기준으로 일반적으로 less&lt;자료형&gt;, greater&lt;자료형&gt; 을 사용하며 less는 내림차순, greater는 오름차순**을 나타냅니다.따라서 본 문제 풀이에서는 아래와 같이 우선순위 큐를 선언해주었습니다. priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; 우선순위 큐에서 오름차순으로 알아서 정렬해주기 때문에, 저희는 정렬에 대한 고민을 할 필요가 없습니다. 따라서 제가 값들을 push하는 족족 오름차순이라는 기준에 맞게 pq.top()요소는 크기가 가장 작은 요소로 정렬되어 있는 것이죠. 그래서 문제에서 요구하는 매운 음식을 섞는 기준을 쉽게 구현할 수 있습니다.다른 사람의 풀이1#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(vector&lt;int&gt; scoville, int K){ int answer = 0; int needHot; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(scoville.begin(), scoville.end()); //우선 순위 큐에 벡터를 효율적으로 넣는 방법!!!! while (pq.top() &lt; K) { if (pq.size() == 1) return answer = -1; needHot = pq.top(); pq.pop(); pq.push(needHot + pq.top() * 2); pq.pop(); answer++; } return answer;}위 코드가 프로그래머스 상에서 많은 추천수를 받기도 했고 제가 영감을 받은 코드입니다.특히나 저는 우선순위 큐를 선언할 때 아래와 같이 쉽고 간단하게 데이터 초기화를 해줄 수 있는지 몰랐습니다. 이렇게 짠다면 저처럼 굳이 for문을 쓰지 않아도 됩니다.priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(scoville.begin(), scoville.end()); //우선 순위 큐에 벡터를 효율적으로 넣는 방법!!!!그 외에 또 인상깊었던 부분이, 저는 while(1)이라는 무한 루프문 안에 if() 조건문을 걸어서 데이터를 조작해주었는데 이를 한꺼번에 while(조건문)으로 구현했다는 점이 확실히 제 코드에 비해서 효율적이었던 것 같습니다. 그 외에 구현 알고리즘은 상당히 비슷합니다.최적화한 나의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int solution(vector&lt;int&gt; scoville, int K){ int answer = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(scoville.begin(), scoville.end()); while (pq.top() &lt; K) { if (pq.size() == 1) { return -1; } int mix = pq.top(); pq.pop(); pq.push(mix + pq.top() * 2); pq.pop(); answer++; } return answer;}그래서 위에 효율적이었던 풀이 방법을 바탕으로 제 코드를 가다듬어보면 위 코드 정도 나올 수 있을 것 같습니다. 이렇게 적고보니까 인상 깊었던 다른 사람의 풀이1와 똑같은 코드가 되어버렸네요^^;;;" }, { "title": "고득점 Kit_ 해시 - Level2 - 전화번호 목록", "url": "/posts/phone-list/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, hash, 고득점, 전화번호 목록, 해시, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 전화번호 목록 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool solution(vector&lt;string&gt; phone_book){ bool answer = true; sort(phone_book.begin(), phone_book.end()); //사전식 정렬을 통한 풀이 for (int i = 0; i &lt; phone_book.size() - 1; i++) { if (phone_book[i + 1].substr(0, phone_book[i].size()) == phone_book[i]) return answer = false; } return answer;}우선 본격적인 설명을 하기 전에 앞서서 넋두리 좀 풀자면, 저는 이 문제 푸는데 시간복잡도 때문에 엄청나게 시간을 빼앗겼습니다… 그러니 이 풀이를 보는 여러분들께서 많은 위안을 가져가셨으면 좋겠습니다.제 알고리즘은 굉장히 심플합니다. 그래서 오래 걸렸다는 것에 더 화가 납니다.우선 정렬해줍니다. 여기서 제일 중요한 것이 있습니다. 너무 중요하니까 강조하고 넘어가겠습니다.sort()란? sort()는 C++ algorithm 라이브러리 내에 있는 정렬 알고리즘입니다. 앞선 포스팅에서도 설명한 적이 있지만 거듭 강조합니다. sort(v.begin(), v.end(), compare);이런 식으로 사용할 수 있는데 compare 자리에 매개변수를 안넘겨주면 디폴트로 오름차순으로 정렬됩니다.네… 이걸 설명하기 위해서 이렇게 강조를 한 것은 아니구요.이 문제에서 다시 한번 짚고 넘어가야 할 부분이 있습니다. 이 문제는 string vector입니다.다들 이미 알고 계셨겠지만 string에서 오름차순이란 사전식 정렬을 뜻합니다.이게 중요합니다. 사전식 정렬… 사전식 정렬… 사전식 정렬…예를 들어서 [“123”, “45”, “456”, “12”, “333”] 이런 Vector가 사전식 정렬이 되면[“12”, “123”, “333”, “45”, “456”]이 되는 것이죠.이제 감이 오시나요? 네… 사실상 문제 풀이 끝난 것입니다.phone_book이 사전식 정렬이 되었기 때문에 우리는 인접 원소끼리만 한번 비교해주면 됩니다.이렇게 time complexity를 줄인 것이죠.접두사로써 포함되는 지 관계 여부를 쉽게 따져주기 위해서 string에서 지원해주는 substr()메소드를 활용했습니다.substr()이란? substr()은 string에서 지원해주는 함수입니다. 부분 문자열을 리턴합니다.해당 함수의 원형은 아래와 같습니다. basic_string substr(size_type pos = 0, size_type count = npos) const; 즉, [pos, pos + count) 까지의 문자열을 반환해주는 함수입니다.우리는 접두사로 부분 문자열이 존재하는 지를 확인하면 되므로 .substr(0, phone_book[i].size()) 위처럼 활용할 수 있습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;bool solution(vector&lt;string&gt; phoneBook) //나와 풀이가 동일하다.{ bool answer = true; sort(phoneBook.begin(), phoneBook.end()); for (int i = 0; i &lt; phoneBook.size() - 1; i++) { if (phoneBook[i] == phoneBook[i + 1].substr(0, phoneBook[i].size())) { answer = false; break; } } return answer;}해당 풀이가 프로그래머스 상에서 가장 많은 추천을 받은 풀이입니다. 저와 풀이가 동일해서 설명은 이하 생략하도록 하겠습니다.다른 사람의 풀이2#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;bool solution(vector&lt;string&gt; phone_book) //unordered_map 해시를 이용한 풀이{ bool answer = true; unordered_map&lt;string, int&gt; hash_map; for (int i = 0; i &lt; phone_book.size(); i++) hash_map[phone_book[i]] = 1; for (int i = 0; i &lt; phone_book.size(); i++) { string phone_number = \"\"; for (int j = 0; j &lt; phone_book[i].size(); j++) { phone_number += phone_book[i][j]; //한개의 전화번호를 한글자씩 떼어내서 phone_number에 기록 if (hash_map[phone_number] &amp;&amp; phone_number != phone_book[i]) //위에서 기록된 부분 전화번호인 phone_number가 hash_map에 있는지 확인! answer = false; } } return answer;}위 알고리즘은 Hash라는 문제 유형에 맞게 C++에서 지원하는 해시인 unordered_map을 활용한 풀이라고 할 수 있습니다. hash_map에 phone_book의 데이터들을 키값으로 넣어준 뒤에, phone_number라는 빈 string에 phone_book[i]의 한글자씩 넣어가면서(부분 문자열인 셈) 해당 부분 문자열이 hash_map에 존재하는지 탐색하는 방식입니다.아래 unordered_map 특징에서도 나오지만, 탐색 시간복잡도가 O(1)로 굉장히 빠르기 때문에 위 코드는 효율적으로 동작합니다.unordered_map이란? unordered_map은 C++에서 지원하는 해시 중 하나입니다. map과는 다소 다른 특징을 가지고 있습니다. unordered_map의 특징은 아래와 같습니다.**1. map보다 더 빠른 탐색을 하기 위한 자료구조 입니다. unordered_map은 해쉬 테이블로 구현한 자료구조로 탐색 시간복잡도는 O(1)입니다. map은 binary search tree로 구현되어 탐색 시간복잡도는 O(logn)입니다. unordered_map은 중복 데이터를 허용하지 않으며 map에 비해 데이터가 많을 시 월등히 좋은 성능을 보여줍니다. Key가 유사한 데이터가 많을 시 해시 충돌로 인해 성능이 떨어질 수 있습니다.** 최적화한 나의 풀이최적화한 풀이가 처음에 본인이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.References https://math-coding.tistory.com/31" }, { "title": "고득점 Kit_ 완전탐색 - Level1 - 모의고사", "url": "/posts/mock-test/", "categories": "Computer science, Algorithm", "tags": "level1, programmers, exhaustive search, 고득점, 모의고사, 완전탐색, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 모의고사 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; answers){ vector&lt;int&gt; answer; vector&lt;int&gt; person1 = {1, 2, 3, 4, 5}; vector&lt;int&gt; person2 = {2, 1, 2, 3, 2, 4, 2, 5}; vector&lt;int&gt; person3 = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5}; vector&lt;int&gt; count = {0, 0, 0}; for (int i = 0; i &lt; answers.size(); i++) { if (answers[i] == person1[i % 5]) count[0]++; if (answers[i] == person2[i % 8]) count[1]++; if (answers[i] == person3[i % 10]) count[2]++; } int max = *max_element(count.begin(), count.end()); for (int i = 0; i &lt; count.size(); i++) { if (max == count[i]) answer.push_back(i + 1); } return answer;}우선 저는 각 학생 별로 정답을 찍는 패턴에 대한 vector를 만들어주었습니다.그리고 인자로 들어오는 answers를 완전탐색하면서 각각의 찍는 패턴과 비교하여 정답일 경우에는 본인 인덱스에 맞는 count vector로 가서 맞춘 횟수를 카운팅하도록 구현하였습니다.또한 모듈러 연산을 활용하여서 각 학생의 패턴 끝에 도달하게 되면 다시 rotation할 수 있도록 만들었습니다.max_element()란? C++ algorithm 라이브러리에 존재하는 최대값을 찾아주는 함수입니다. 더 정확히 말하자면 위 메소드는 최대값을 리턴하지 않고 최대 값이 존재하는 위치, 즉 포인터 혹은 이터레이터를 리턴합니다. max_element(v.begin(),v.end()) 위처럼 사용되곤 하는데 역시 중요한 것은 v.end()는 마지막 원소가 아닌 마지막 원소의 인덱스+1의 위치를 리턴합니다. 그 부분을 통해 눈치챌 수 있듯이 위 메소드 역시 [v.begin(),v.end())의 범위 내에서 max 값을 찾아낸다는 것에 주의가 필요합니다.만약에 최소값을 찾고 싶다면 min_element(v.begin(), v.end())를 사용하시면 됩니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; one = {1, 2, 3, 4, 5};vector&lt;int&gt; two = {2, 1, 2, 3, 2, 4, 2, 5};vector&lt;int&gt; thr = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};vector&lt;int&gt; solution(vector&lt;int&gt; answers){ vector&lt;int&gt; answer; vector&lt;int&gt; they(3); for (int i = 0; i &lt; answers.size(); i++) { if (answers[i] == one[i % one.size()]) they[0]++; if (answers[i] == two[i % two.size()]) they[1]++; if (answers[i] == thr[i % thr.size()]) they[2]++; } int they_max = *max_element(they.begin(), they.end()); for (int i = 0; i &lt; 3; i++) { if (they[i] == they_max) answer.push_back(i + 1); } return answer;}프로그래머스에서 가장 많은 추천수를 받은 풀이 방법입니다. 제 풀이와 거의 일치하여서, 이하 설명은 생략하도록 하겠습니다.최적화한 나의 풀이최적화된 풀이가 필자가 처음에 푼 풀이와 동일하여 생략합니다." }, { "title": "고득점 Kit_ 정렬 - Level1 - K번째수", "url": "/posts/Kth-number/", "categories": "Computer science, Algorithm", "tags": "level1, programmers, sort, 고득점, K번째수, 정렬, 알고리즘, 코딩 테스트, 프로그래머스", "date": "2021-08-09 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - K번째수 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; array, vector&lt;vector&lt;int&gt;&gt; commands){ vector&lt;int&gt; originalArray = array; vector&lt;int&gt; answer; for (int i = 0; i &lt; commands.size(); i++) { sort(array.begin() + commands[i][0] - 1, array.begin() + commands[i][1]); answer.push_back(array[commands[i][0] + commands[i][2] - 2]); array = originalArray; } return answer;}이 문제는 정렬 문제답게 정렬이 핵심이고 Vector로 인자가 넘어오기 때문에 Vector에 인덱스 접근을 잘하는 것이 매우 중요합니다. 저는 오름차순 정렬을 위해 algorithm 라이브러리에 있는 sort를 활용하였습니다.sort()란? c++ algorithm 라이브러리에 존재하는 정렬 알고리즘으로, 내부적으로 퀵 정렬로 구현되어 있어서 시간 복잡도가 O(nlogn)으로 빠른 편입니다. 함수의 원형은 아래와 같이 생겼습니다. template &lt;typename T&gt;void sort(T start, T end, Compare comp); 위에서 보면 알 수 있겠지만, 첫번째와 두번째 인자로는 정렬할 시작점과 끝점을 정해주게 됩니다.여기서 가장 중요한 것은 정렬이 되는 범위입니다. 보통 [start, end]라고 오해하는 경우가 있는데(필자 본인 이야기) 사실 정렬되는 범위는 [start, end) 이므로 반드시 주의해야 합니다.그 외에 알고리즘은 Vector의 이터레이터와 인덱스 접근에 대하여 실수하지 않고 잘 이해하고 있다면 쉽게 이해할 수 있을 것입니다. 하나 특이한 점으로는 저는 originalArray라는 변수를 두어서 기존에 넘어온 array 배열 자체에 조작을 가하고, for문의 1 cycle이 끝나면 다시 originalArray로 복원해주는 방식을 선택하였습니다.다른 사람의 풀이1#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; array, vector&lt;vector&lt;int&gt;&gt; commands){ vector&lt;int&gt; answer; vector&lt;int&gt; temp; for (int i = 0; i &lt; commands.size(); i++) { temp = array; sort(temp.begin() + commands[i][0] - 1, temp.begin() + commands[i][1]); answer.push_back(temp[commands[i][0] + commands[i][2] - 2]); } return answer;}프로그래머스에서 가장 많은 추천수를 받은 풀이 방법입니다. 제 풀이와 완전 동일하여서 스스로 놀랐고, 이하 설명은 생략하도록 하겠습니다.최적화한 나의 풀이최적화된 풀이가 필자가 처음에 푼 풀이와 동일하여 생략합니다." }, { "title": "기술 면접_ 세마포어와 뮤텍스 차이", "url": "/posts/semaphore-mutex/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 세마포어, 뮤텍스, computer science, technical interview, semaphore, mutex", "date": "2021-08-08 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.본격적으로 세마포어와 뮤텍스에 대하여 알아보기 전에 임계 구역(Critical Section)에 대하여 이해해 봅시다.임계 구역(Critical Section)이란? 임계 구역(Critical Section)은 여러 프로세스 혹은 스레드가 작업을 수행하면서 공유된 자원을 건드리게 될 수 있는데, 이때 동기화 처리를 제대로 해주지 않으면 문제가 발생할 수 있다고 저번 프로세스와 스레드 차이 포스팅에서 배웠습니다. 이렇듯 공유되는 부분이 굉장히 중요한데, 프로그램 코드 상에서 공유 자원에 접근하는 부분을 임계 구역(Critical Section)이라고 합니다.이렇게 임계 구역에 여러 프로세스 및 스레드가 함부로 접근할 수 없도록 관리를 잘 해줘야 하는데, 이를 위해 사용하는 방식에 대표적으로 세마포어(Semaphore)와 뮤텍스(Mutex)가 있습니다.세마포어(Semaphore)란? 세마포어(Semaphore)는 공유 자원에 여러 프로세스가 접근하는 것을 막는 것을 말합니다. 세마포어는 이를 위해서 현재 공유 자원의 상태를 나타내는 카운터 변수를 사용하게 됩니다. 이러한 변수는 실제로 운영체제 혹은 커널에 값으로 저장되며, 각 프로세스는 이를 확인할 수 있고 값을 변경할 수도 있게 됩니다.각각의 프로세스들은 이런 상태값을 확인하여 자원을 즉시 사용할 수 있는 상태라면 즉시 사용할 수 있고 만약에 누군가가 자원을 사용중이라는 것을 인지하게되면, 반드시 일정 시간을 기다렸다가 사용하게 됩니다. 이런 방식을 통해 여러 프로세스가 공유 자원에 한꺼번에 접근하는 것을 막을 수 있습니다.큰 특징으로는, 세마포어는 뒤에 나올 뮤텍스와 다르게 0혹은 1과같은 이진수 외에 더 큰 숫자를 가지게 할 수도 있어서 꼭 1개의 프로세스만이 자원을 점유하지는 않습니다. 카운터 변수의 값이 해당 공유 자원에 접근할 수 있는 임계치가 되며 이를 조정하여 접근할 수 있는 프로세스의 개수를 통제할 수 있습니다.뮤텍스(Mutex)란? 뮤텍스(Mutex)는 상호 배제(Mutual Exclusion)를 뜻하는 말로, Critical Section을 가지는 쓰레드들의 Running time이 서로 겹치지 않도록 해주는 기법입니다.세마 포어와 가장 큰 차이점으로는 공유 자원에 접근할 수 있는 대상의 개수 차이입니다. 뮤텍스는 1개의 스레드만이 공유 자원에 접근할 수 있도록 합니다. 뮤텍스에서는 Lock과 Unlock개념을 사용합니다. 즉, 이진 세마포어(Binary Semaphore)와 같은 개념입니다. 자원을 점유하고 있는 대상이 Lock을 할 수 있는 권한을 가지고 있어서 자원을 점유하기 시작할 때 들어가서 Lock을 걸어버립니다. 이렇게 되면 다른 대상들은 Unlock 상태가 될 때까지 기다렸다가 나중에 해당 공유 자원에 접근할 수 있게 됩니다.결론 뮤텍스(Mutex)는 이진 세마포어(Binary Semaphore)로 세마포어의 일종입니다. 가장 큰 차이점으로는 뮤텍스는 오직 1개의 프로세스 혹은 스레드만이 공유 자원에 접근할 수 있고, 세마포어는 지정된 변수의 값만큼 접근할 수 있습니다. 또한 세마포어는 운영체제 혹은 커널 단위에서 해당 리소스 변수가 관리되어 현재 공유 자원을 사용 중인 대상 뿐만아니라 다른 프로세스 및 스레드도 잠금 상태를 해제할 수 있지만 뮤텍스는 프로세스 단에서 관리되고 해당 변수(Lock)을 가지고 있기 때문에 Lock을 가지고 있는 변수만이 Unlock을 할 수 있습니다.References https://jwprogramming.tistory.com/13https://junghyun100.github.io/Semaphore&amp;Mutex/" }, { "title": "기술 면접_ 프로세스와 스레드 차이", "url": "/posts/process-thread/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 스레드, 프로세스, computer science, technical interview, thread, process", "date": "2021-08-08 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.프로세스란? 프로그램이 메모리에 올라가서 실행이 될 때, 실행되고 있는 그러한 상태 단위를 프로세스라고 합니다.본 포스팅에서는 이해를 돕기 위해서 제가 좋아하는 음식인 햄버거를 예로 들어 설명하겠습니다.햄버거를 만드는 프로그램이 있다고 가정해볼게요. 이렇게 햄버거를 만드는 프로그램이 메모리에 올라가서 실행중인 상태가 되는데 그 상태 단위를 프로세스라고 합니다.스레드란? 우리가 위에서 햄버거를 만드는 프로그램을 예ㅍ시를 통해 프로세스에 대하여 알아봤는데요. 스레드를 쉽게 이해하기 위해서 햄버거를 만드는 프로그램에 대하여 알아봅시다! 햄버거를 만드는 프로그램 내부 로직을 간단하게 만들어 볼까요? 햄버거 만드는 과정 햄버거 빵, 패티, 야채, 소스를 준비해줍니다. 햄버거 빵을 먹기 좋게 구워줍니다. 패티를 구워줍니다. 구워진 햄버거 빵에 야채, 소스와 함께 다 구워진 패티를 넣어줍니다. 맛있는 햄버거 완성~! 위 과정이 햄버거 만드는 프로그램 내부적으로 실행되는 로직이 되겠죠. 즉, 저희는 지금 햄버거 프로그램의 프로세스에 대하여 알아본 것이에요! 햄버거 프로그램 1개에 이렇게 다양한 명령의 흐름이 있다는 걸 알게되었군요. 이 각각의 명령 흐름이 스레드라고 이해하시면 됩니다!즉, 스레드는 프로세스 내에서 실행되는 여러 흐름의 단위입니다.아니 그렇다면, 프로세스가 스레드를 포함하는 개념인 것은 이해가 되었는데 프로세스와 스레드의 차이점이 무엇일까요? 차이점을 알아보기 전에 멀티 프로세스와 멀티 스레드에 대한 개념을 좀 짚고 넘어갈 필요가 있어요.멀티 프로세스란? 멀티 프로세스란 이름에서 유추할 수 있듯이 프로세스 여러개를 통해 하나의 작업을 수행함을 의미합니다.멀티 스레드란? 멀티 스레드는 멀티 프로세스와는 조금 다르게 하나의 작업을 여러개의 프로세스가 아닌 하나의 프로세스 관점에서 스레드를 여러개 나누어서 수행함을 의미하죠.즉, 어떤 동일한 하나의 작업을 여러 개의 프로세스 단위로 나눠서 처리를 하는 지 혹은 여러 개의 스레드 단위로 나눠서 처리를 하는 지에 따라서 두 방식이 나뉜다고 생각하면 좋을 것 같아요.이렇게 두 방식을 나눠서 쓰는 이유가 있겠죠? 무엇이 다른 지 알아볼까요?멀티 스레드와 멀티 프로세스의 차이? 우선 멀티 스레드 방식과 멀티 프로세스의 대표적인 차이점이 있어요. 바로 같은 프로세스 내부에 있는 스레드 끼리는 데이터를 공유할 수 있다는 큰 이점이 있지요. 이런 장점을 통해 멀티 스레드 방식은 멀티 프로세스 방식에 비해 메모리 공간을 적게 사용하며 효율성을 높일 수 있어요. 또한, 하나의 작업을 수행하기 위해서 여러가지 스레드가 번갈아가면서 즉, 파이프 라이닝에 기반하여 실행되는데 이때 기존에 작업하던 스레드에서 다른 스레드로 넘어가는 전환 과정을 context switching라고 부릅니다. 멀티 프로세스에서도 하나의 작업을 수행하기 위해서 프로세스 간의 저런 전환 과정을 가지는데 그에 비해서 멀티 스레드는 공유 자원을 가지고 있기 때문에 context switching에 들어가는 비용이 절감되는 큰 장점을 가지고 있습니다. 이렇게 장점만 있으면 멀티 스레드만 쓰고 멀티 프로세스 방식은 안쓰겠지요?고로, 멀티 스레드 방식에는 큰 단점도 존재합니다. 자원을 공유하는 만큼 공유 자원에 대한 관리가 필요합니다. 공유 자원에 동시에 접근하여 데이터 조작을 가하게 되면 예기치 못한 오류들이 발생할 수 있기 때문에 프로그래머는 이런 데이터의 동기화 문제를 반드시 고려하여 신중하게 프로그래밍해야 합니다. 즉 프로그래밍하기가 더 까다롭다는 것이죠.결론 하나의 작업을 여러 단위로 나누어 수행한다는 점에 있어서는 동일하지만, 멀티 스레드는 공유 자원을 활용한다는 점에서 메모리 공간 절약 및 context switching 비용 감소 등과 같은 큰 장점을 가지고 있습니다. 하지만 공유 자원을 사용하는 만큼 프로그래머에게 데이터 동기화 문제에 대한 처리를 해야 한다는 까다로움이 발생합니다.따라서, 멀티 프로세스와 멀티 스레드를 용도와 환경에 맞게 고루 사용하는 것이 중요합니다.References https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/" }, { "title": "기술 면접_ 컴퓨터 메모리 구조", "url": "/posts/memory-architecture/", "categories": "Computer science, Technical interview", "tags": "CS, 기술 면접, 메모리 구조, computer science, technical interview, memory architecture", "date": "2021-08-08 00:00:00 +0900", "snippet": "!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.프로그램 실행 원리 프로그램은 기본적으로 위와 같은 동작 순서로 실행됩니다. 사용자가 운영체제에게 프로그램 실행 요청을 합니다. 프로그램을 HDD나 SSD같은 보조기억장치로 부터 읽어 메모리에 로드합니다. CPU는 메모리에 올라간 Code영역 내부에 프로그램 실행 명령어들을 통해 프로그램을 실행합니다. 프로그램 내부 로직에서 동적으로 메모리를 할당하는 요청이 있으면 해당 부분은 Heap 영역에 할당합니다. 프로그램 내부 로직에서 함수가 호출되어 지역 변수 혹은 매개 변수를 사용하면 Stack 영역에 할당해줍니다. 메모리 공간 요소 메모리는 위와 같이 크게 총 4가지의 영역으로 구분됩니다. Code 영역 Data 영역 Heap 영역 Stack 영역 Code 영역이란? Code 영역은 프로그램의 소스 코드가 담기는 부분입니다. 사용자가 프로그램을 실행하기 위해서 OS에 요청을 보내면 프로그램 실행 코드가 Code 영역에 담기게 되고, CPU가 Code 영역에 담긴 프로그램 실행 명령어들을 처리하여 실행하는 방식으로 프로그램이 실행됩니다.Data 영역이란? Data 영역은 전역 변수와 Static 변수가 할당되는 지역으로 전역 변수 및 Static 변수의 특징에 맞게 프로그램이 실행될 때 할당 되었다가 프로그램이 종료될 때 모두 할당 해제됩니다.Heap 영역이란? Heap 영역은 프로그래머가 동적으로 할당하거나 해제할 때 할당받는 메모리 영역입니다. 대표적으로 C 언어에서 malloc()과 같은 메소드를 통해서 할당하고 free()라는 메소드를 통해서 할당 해제할 수 있습니다.위 영역은 런 타임에 메모리 크기가 결정됩니다.Stack 영역이란? Stack 영역은 함수 호출 시 사용되는 지역 변수 및 매개 변수가 할당되는 영역입니다. 함수가 호출되면 생성되었다가 해당 함수가 종료되면 사라지는 임시 메모리 공간입니다.Heap과 Stack간의 관계 Heap과 Stack은 사실 하나의 메모리 공간을 나눠서 사용합니다. 하나의 큰 메모리 공간을 Heap 영역은 메모리 주소상 아랫 주소부터 사용하고 Stack은 메모리 주소상 윗 주소부터 할당해 나가면서 서로 점유하는 형태입니다. 그러다가 공유해서 쓰는 하나의 메모리 공간을 다 쓰게되면 서로 영역의 침범하게 되는데 그러한 상황을 Heap overflow 혹은 Stack overflow라고 부릅니다.References https://jinshine.github.io/2018/05/17/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B8%B0%EC%B4%88/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0/" }, { "title": "고득점 Kit_ 스택/큐 - Level2 - 기능개발", "url": "/posts/functional-development/", "categories": "Computer science, Algorithm", "tags": "level2, programmers, queue, stack, 고득점, 기능개발, 스택, 알고리즘, 코딩 테스트, 큐, 프로그래머스", "date": "2021-08-05 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 기능개발 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; days;vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds);void calcDays(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds);vector&lt;int&gt; calcDistributes(vector&lt;int&gt; answer);vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ vector&lt;int&gt; answer; calcDays(progresses, speeds); answer = calcDistributes(answer); return answer;}void calcDays(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ for (int i = 0; i &lt; progresses.size(); i++) { float number = ceil((100.0 - static_cast&lt;float&gt;(progresses[i])) / speeds[i]); days.push_back(number); }}vector&lt;int&gt; calcDistributes(vector&lt;int&gt; answer){ int count = 0; int size = days.size(); for (int i = 0; i &lt; size; i++) { if (days[0] &lt; days[1] || days.size() == 1) { answer.push_back(++count); count = 0; days.erase(days.begin()); } else { count++; days.erase(days.begin() + 1); } } return answer;}우선, 각 기능별로 스피드에 대비해서 몇일의 시간이 소요되는지를 계산하고 저장하기 위한 days라는 전역 벡터를 두었습니다. 위 계산은 calcDays 메소드에서 이루어집니다. calcDays에서 나름 깔끔하게 짰다고 생각하는 코드가 아래 코드입니다. 효율적이라고 많은 추천을 받은 다른 풀이와 비교했을 때도 손색이 없는 코드라고 생각합니다. 올림을 통해 계산하였습니다.float number = ceil((100.0 - static_cast&lt;float&gt;(progresses[i])) / speeds[i]);그 후 calcDistributes 메소드에서 위에서 구한 days를 활용하여 각 배포시마다 몇개의 기능이 배포되는지 구할 수 있도록 구현하였습니다. 기본적으로는 days[0]과 days[1]을 비교하면서 count를 늘려주고 배포할 시점이 오면 answer 벡터에 push_back()해주는 방식으로 처리하였습니다.다른 사람의 풀이1vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ vector&lt;int&gt; answer; int day; int max_day = 0; for (int i = 0; i &lt; progresses.size(); ++i) { day = (99 - progresses[i]) / speeds[i] + 1; //내 코드 1줄과 같은 과정이지만 이개 더 깔끔하다. 99가 핵심이다. if (answer.empty() || max_day &lt; day) //이 부분이 내 코드에 비해서 훨씬 효율적이다. 큰 영감을 얻을 수 있었다. answer.push_back(1); else ++answer.back(); if (max_day &lt; day) max_day = day; } return answer;}위 풀이는 프로그래머스에서 가장 많은 추천을 받은 풀이입니다. 저와 마찬가지로 작업 시간을 담는 day 변수가 있는데 제 코드보다 더 깔끔한 것 같습니다. 바로 아래의 코드입니다.day = (99 - progresses[i]) / speeds[i] + 1;사실 위 코드보다 아래의 알고리즘에서 더욱 큰 영감을 받을 수 있었습니다. max_day라는 변수를 통해 이전 탐색까지의 최대 작업 일수를 저장하고 for loop 속에서 max_day와 day를 비교하면서 배포 시점을 정해준 알고리즘입니다. 위 방식대로하면 처음에 짰던 제 코드보다 훨씬 더 짧고 이해하기 쉬운 코드를 구현할 수 있습니다.다른 사람의 풀이2vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ vector&lt;int&gt; answer; queue&lt;int&gt; q; //queue를 활용한 풀이이다. for (int i = 0; i &lt; progresses.size(); i++) { int temp = (100 - progresses[i]) % speeds[i]; if (temp == 0) q.push((100 - progresses[i]) / speeds[i]); else q.push((100 - progresses[i]) / speeds[i] + 1); } while (!q.empty()) //큐로 관리하는 부분이다. { int cnt = 1; int cur = q.front(); q.pop(); while (cur &gt;= q.front() &amp;&amp; !q.empty()) { q.pop(); cnt++; } answer.push_back(cnt); } return answer;}위 코드는 또다른 풀이법인데, 스택/큐 문제 유형에 잘 부합하게 큐를 통하여 풀이한 알고리즘입니다. 자료구조를 queue로 짰다는 것 외에는 거의 비슷한 로직이라서 이하 설명은 생략하도록 하겠습니다.최적화한 나의 풀이vector&lt;int&gt; days;vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds);void calcDays(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds);vector&lt;int&gt; calcDistributes(vector&lt;int&gt; answer);vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ vector&lt;int&gt; answer; calcDays(progresses, speeds); answer = calcDistributes(answer); return answer;}void calcDays(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds){ for (int i = 0; i &lt; progresses.size(); i++) { float number = ceil((100.0 - static_cast&lt;float&gt;(progresses[i])) / speeds[i]); days.push_back(number); }}vector&lt;int&gt; calcDistributes(vector&lt;int&gt; answer){ int maxDay = 0; for (int i = 0; i &lt; days.size(); i++) { if (maxDay &lt; days[i]) { answer.push_back(1); maxDay = days[i]; } else answer.back()++; } return answer;}제가 기존에 함수화 시켜놨던 모듈들은 그대로 유지시키고 싶어서, 다른 사람 풀이1에 비해서 비효율적이었던 calcDistributes() 메소드 부분을 위처럼 수정해주었습니다." }, { "title": "고득점 Kit_ 해시 - Level1 - 완주하지 못한 선수", "url": "/posts/incomplete-runner/", "categories": "Computer science, Algorithm", "tags": "hash, level1, programmers, 고득점, 알고리즘, 완주하지 못한 선수, 코딩 테스트, 프로그래머스, 해시", "date": "2021-08-04 00:00:00 +0900", "snippet": "!본 포스팅은 프로그래머스 코딩테스트 고득점 Kit - 완주하지 못한 선수 풀이입니다.처음으로 맞춘 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string solution(vector&lt;string&gt; participant, vector&lt;string&gt; completion){ sort(participant.begin(), participant.end(), [](string a, string b) //시간 복잡도 문제 때문에 각각을 정렬한 뒤에 비교하는 방식을 취함 { return a &lt; b; }); sort(completion.begin(), completion.end(), [](string a, string b) { return a &lt; b; }); for (int i = 0; i &lt; completion.size(); i++) { if (completion[i] != participant[i]) { string answer = participant[i]; return answer; } } string answer = participant.back(); return answer;} 이 문제가 코딩테스트 준비의 첫걸음이라고 말할 수 있을 정도로, 코딩테스트 공부를 본격적으로 처음 공부해본 저는, 처음에는 이중 포문을 사용해서 문제 풀이를 시작했었습니다. 하지만, 시간 복잡도에 의해서 효율성 측면에서 어김없이 오답… 그래서 구글링을 통해 정렬을 한 뒤 비교를 하는 방식을 태하여 문제 풀이를 이어 나갔습니다. ` Tip! 문제 속 입력 값의 개수를 보고 시간 복잡도를 많이 따지는 문제인지 아닌지를 판가름하여 해결하면 더욱 편리하게 풀 수 있습니다.`다른 사람의 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string solution(vector&lt;string&gt; participant, vector&lt;string&gt; completion){ string answer = \"\"; sort(participant.begin(), participant.end()); sort(completion.begin(), completion.end()); for (int i = 0; i &lt; completion.size(); i++) { if (participant[i] != completion[i]) return participant[i]; } return participant[participant.size() - 1]; //return answer;} 다른 사람의 풀이 역시 저와 일치하는 풀이법이네요. 정렬을 한 뒤에 비교 해준 풀이 방식입니다.최적화한 나의 풀이 최적화된 풀이가 처음에 본인이 푼 풀이와 거의 비슷하여 생략합니다." } ]
